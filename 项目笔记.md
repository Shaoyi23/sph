# Day1

各个文件的意义

以防拼写错误，可以在vscode下个插件：`Code Spell Checker`

## **1. vue-cli脚手架初始化项目**

​    node + webpack + 淘宝镜像

<strong style = "color:orange">node_modules文件夹：</strong>项目依赖文件夹

<strong style = "color:orange">public文件夹：</strong>一般防止一些静态资源（图片等），需注意，放在public文件夹中的静态资源，webpack进行打包的时候，会原封不动打包到dist文件夹中。

<strong style = "color:orange">src文件夹（程序员源代码文件夹）：</strong>
        <strong style = "color:orange">assets文件夹：</strong>一般是放置静态资源（一般放置多个组件共用的静态资源），需注意，放置在assets文件夹里的静态资源，在webpack打包时，会把它当做一个模块，打包到JS文件里。
        <strong style = "color:green">components文件夹：</strong>一般放置的是非路由组件（全局组件）。
        <strong style = "color:green">App.vue：</strong>唯一的根组件，Vue当中的组件（.vue）。
        <strong style = "color:#ebd300">main.js：</strong>程序入口文件，也是整个程序当中最先执行的文件。
<strong style = "color:#ebd300">babel.config.js：</strong>配置文件（babel相关）。
<strong style = "color:#ebd300">package.json文件：</strong>类似于项目的‘身份证’，记录项目叫什么，当中有哪些依赖，如何运行。
<strong style = "color:#ebd300">package.lock.json文件：</strong>缓存性文件。
<strong style = "color:skyblue">README.md文件：</strong>说明性文件。
    

## **2. 项目的其他配置**

### **2.1 项目运行起来的时候，让浏览器自动打开**

​    ------package.json文件中

```js
        "scripts": {
        "serve": "vue-cli-service serve --open",
        "build": "vue-cli-service build",
        "lint": "vue-cli-service lint"
    },
```

### **2.2 eslint校验功能关闭**

​	------在根目录下，创建一个vue.config.js
比如：声明变量但未使用eslint校验工具报错。

```js
module.exports = {
    //关闭eslint
    lintOnSave: false
}
```

### **2.3 src文件夹简写方法，配置别名**

**jsconfig.json配置别名@提示**  
【@代表的是src文件夹，常在js文件中使用，@不能在"node_modules"和"dist"使用】
{
    "compilerOptions":{
        "baseUrl":"./",
        "paths":{
                "@/*":["src/*"]
            }
    },

    "exclude":["node_modules","dist"]
}

**也可在css中配置别名@提示**

【background-image: url(~@/assets/images/icons.png);】

  

## **3. 项目路由的分析**

vue-router
前端的路由：KV键值对。
**key：**URL（地址栏中的路径）
**value：**相应的路由组件
注：本次项目是上中下结构

本次项目的**路由组件**可分为：
Home首页路由组件、Search搜索路由组件、login登录路由组件、Refister注册路由组件

本次项目的**非路由组件**可分为：
Header组件：【存在于首页、搜索页】
Footer组件：【存在于首页、搜索页，但登录和注册页面没有】



## **4. 完成非路由组件Header与Footer业务**

本次项目主要关注业务、逻辑。
开发项目步骤：
1.书写静态页面（HTML+CSS）(本次项目已提前准备好了)
2.拆分组件
3.获取服务器的数据动态展示
4.完成相应的动态业务逻辑

注1.创建组件时，组件结构 + 组件的样式 + 图片资源。
注2.采用的是less样式，需通过less、less-loader【安装版本五的`npm install --save less less-loader@5`】进行处理less，将其变为css样式。
注3.若想让组件识别less样式，需在style标签上加上lang=less



## **5. 路由组件的搭建**

vue-router
在上面分析时，本次项目的路由组件有四个：
Home首页路由组件、Search搜索路由组件、Login登录路由组件、Register注册路由组件。

  --components文件夹：经常放置非路由组件（共用全局组件）.
  --pages|views文件夹：经常放置路由组件.

###   **5.1 配置路由**

  项目当中配置的路由一般放置在router文件夹中的index.js里。

###   **5.2 总结**

​    路由组件与非路由组件的区别？
​        1.路由组件一般放置在pages|views文件夹中，非路由组件(普通组件)一般放置在components文件夹中。
​        2.路由组件一般需要在router文件夹中进行注册（使用的名字即为组件的名字，例如router文件中的index.js里的写法），在App.vue中展示时，用的是<router-view></router-view>；非路由组件在使用时，一般以标签的形式使用（例如App.vue里的<Header></Header>标签）。
​        3.注册完路由，不管是路由组件、还是非路由组件，它们身上都会有$route、$router属性。
​            $route：一般获取路由信息【路径、query、params等】
​            $router：一般进行编程式导航，进行路由跳转【push|replace（其中一个是有缓存记忆的）】

###   **5.3 路由的跳转**

​        路由跳转的两种形式：
​            ① 声明式导航：router-link
​            ② 编程式导航：push|replace

            其中，编程式导航：声明式导航能做的，编程式导航都能做；但编程式导航还可以进行路由跳转，做一些其他业务逻辑。
    
        在router的index.js里书写重定向代码：
            重定向：在项目跑起来时就访问该页面(该方法可以立马让其定向到首页)



## **6. Footer组件显示与隐藏**

显示or隐藏，用v-if|v-show
Footer组件：在Home、Search显示Footer组件，但是在登录、注册时隐藏的。

###   **6.1**

  可根据组件身上的$route获取当前路由的信息，通过路由路径判断Home和Footer这俩非路由组件的显示与隐藏。

  ```vue
  <!-- 写法一(不推荐)： -->
        <Footer v-show="$route.path=='/home'||$route.path=='/search'"></Footer>
  
  ```

###   **6.2**

  配置路由时，可给路由添加路由元信息【meta】，注意路由配置对象的key不能乱写。

在APP.vue文件中：

```vue
 <!-- 写法二： -->
      <Footer v-show="$route.meta.show"></Footer>
 
```

在router文件的index.js中：

  ```js
  //配置路由
export default new VueRouter({
    //配置路由
    routes: [{
            path: "/home",
            component: Home,
            meta: { show: true }
        },
        {
            path: "/search",
            component: Search,
            meta: { show: true }
        },
        {
            path: "/login",
            component: Login,
            meta: { show: false }
        },
        {
            path: "/register",
            component: Register,
            meta: { show: false }
        },
        //重定向：在项目跑起来时就访问该页面(该方法可以立马让其定向到首页)
        {
            path: '*',
            redirect: './home'
        }

    ]
})
  ```





## 7. 路由传参

###   7.1 路由跳转的几种方法？

​	eg：A -> B

​	**①声明式导航：**router-link（务必要有to属性），可实现路由跳转。

​	**②编程式导航：**利用组件实例的$router.push|replace方法，可实现路由的跳转，也可书写一些自己的业务逻辑。

###   7.2 路由传参有几种写法？

​	**①params参数：**属于路径当中的一部分，需注意，在配置路由的时候，需要占位。

​	**②query参数：**不属于路径当中的一部分，类似于ajax中的queryString    /home?k=v&kv=, 不需占位。







## 7.3. 关于路由传参相关的面试题

### **面试题1：**路由传参（对象的写法）path是否可以结合params参数一起使用？

   **答：**不能。路由跳转传参时，对象写法可为name、path形式，但是path这种写法不能与params参数一起使用。而且，路径参数缺失是无法匹配path里的占位符的。

 

```js
this.$router.push({path:"search",params:{keyword:this.keyword},query:{k:this.keyword.toUpperCase()}})
```

应改写成：

```js
this.$router.push({name:"search",params:{keyword:this.keyword},query:{k:this.keyword.toUpperCase()}})
```

/************************************************************************************************/

### **面试题2：如何指定params参数可传可不传？**

   **答：**若路由要求传params参数，但未传，则URL会产生问题。

```js
methods：{
  this.$router.push(
    {name:"search",
    query:{
        k:this.keyword.toUpperCase()
    	}
    }
  )
},
```

则得到的地址为：http://localhost:8080/#/?k=ABC

 

```js
methods：{
  this.$router.push(
    {name:"search",
    params:{
        keyword:this.keyword},
    query:{
        k:this.keyword.toUpperCase()
    	}
    }
  )
},
```

，则得到的地址为：http://localhost:8080/#/search/abc?k=ABC

  **如何指定params参数可传或可不传？**

​    **答：**在配置路由(router文件中的index.js)时，在占位的后面加上一个问号?即：`path: "/search/:keyword?"`,【这里的?表示params可传递或可不传递(和正则表达式雷同，?代表出现次数为0次或1次，即可有可无)】

```js
//配置路由
export default new VueRouter({
    //配置路由
    routes: [
        {
            path: "/search/:keyword?",
            component: Search,
            meta: { show: true },
            name: "search"
        },
    ]
})
```



### **面试题3：params参数可传递也可不传递，但若传递空字符串，如何解决？**

​	**答：**params传递空字符串也会产生URL问题。可通过在其传递的空字符串后面加上`||undefined`进行解决。

```js
methods：{
  this.$router.push(
    {name:"search",
    params:{
        keyword:''||undefined},
    query:{
        k:this.keyword.toUpperCase()
    	}
    }
  )
},
```

### 面试题4：路由组件能否传递props数据？

   // 答：可以。有三种写法：

   this.$router.push({path:"search",params:{keyword:this.keyword},query:{k:this.keyword.toUpperCase()}})

​    **方式一：**props用布尔值，但只能传递params

   // props: true,

​    **方式二：**对象写法。额外给路由组件传递一些props

   // props: { a: 1, b: 2 },

​    **方式三：**函数写法。可params参数、query参数，通过props传递给路由组件

   props: ($route) => {

​     return { keyword: $route.params.keyword, k: $route.qyert.k }

   } 





# Day2

## 8. 重写push和replace

为什么编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的警告错误？

​		--路由跳转有两种形式：①.声明式导航、②.编程式导航

​		--声明式导航没有这类问题，因为vue-router底层已经处理好了。

​		**8.1 为什么编程式导航进行路由跳转时，会有这种警告错误？**

​		因为最新版本的vue-router引入了promise

​		1.通过给push方法传递相应的成功、失败的回调函数，可捕获到当前错误，可以解决。

​		2.通过底部的代码，可实现解决错误。

​		**方法一**(治标不治本，在将来的组件当中push|replace，编程式导航还是会有类似警告错误)：

```js
this.$router.push({name:"search",params:{keyword:this.keyword},query:{k:this.keyword.toUpperCase()}},()=>{},()=>{})
```

​		**方法二**(在router文件夹中的index.js中)：

```js
//若有成功和失败的回调，有则返回这俩值，无则自己手写() => {}
//先把VueRouter原型对象的push先保存一份
let originPush = VueRouter.prototype.push;
//先把VueRouter原型对象的replace先保存一份
let originReplace = VueRouter.prototype.replace;
//重写push|replace
//第一个参数location：告诉原来的push方法，你往哪里跳转（传递哪些参数）
//第二个参数resolve：成功回调。
//第三个参数reject：失败回调。
//call|apply区别
//相同点：都可调用函数一次，都可篡改函数的上下文一次。
//不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行，传递数组。
VueRouter.prototype.push = function(location, resolve, reject) {
    if (resolve && reject) {
        originPush.call(this, location, resolve, reject);
    } else {
        originPush.call(this, location, () => {}, () => {})
    }
}
VueRouter.prototype.replace = function(location, resolve, reject) {
    if (resolve && reject) {
        originReplace.call(this, location, resolve, reject);
    } else {
        originReplace.call(this, location, () => {}, () => {})
    }
}
```





## 9. Home首页组件拆分业务分析

本次项目的Home首页被拆分为了七个部分。

完成步骤：

​		-- 先把静态(css、html)页面完成。

​		-- 拆分出静态组件。

​		-- 获取服务器的数据进行展示。

​		-- 若有js的动态业务，则将其完成即可。

### 9.1. TypeNav的三级联动全局组件完成

​		-- 由于三级联动，在Home、Search、Detail，把三级联动注册为全局组件。优点：只需注册一次，即可在项目任意地方使用。

 		-- 本次讲解的组件是属于Home模块下的组件，所以在pages的Home文件夹下新建个文件夹(这里取名为TypeNav)

### 9.2. 完成其余静态组件

**需要耐心、需要注意：**

**HTML + CSS + 图片静态资源  —————信息的【结构、样式、图片资源】，其文件的名字、文件引用路径需要一一对应**



## 10. POSTMAN测试接口

利用postman工具测试接口是否正常

​		--通过postman工具测试，接口无问题。

​		--若服务器返回的数据code字段为200，代表服务器返回数据成功。

​		--整个项目，接口前缀会有/api字样



## 11. axios二次封装

axios文档网：http://www.axios-js.com/zh-cn/docs/

**封装的方法：**XMLHttpRequest、fetch、JQ、axios

本次项目在api文件夹下的request.js文件进行axios的二次封装。

​		**11.1 为什么需要进行二次封装axios？**

​		为了请求拦截器、响应拦截器。

​		**请求拦截器**：可以在发请求之前，可处理一些业务。

​		**响应拦截器**：当服务器数据返回后，可处理一些事情。

**安装axios**

​		**11.2 在项目中，经常会有API文件夹【里面存放的就是axios请求的】**

​		使得接口当中，路径都带有/api：**<strong style ="color:orange">baseURL:"/api"</strong>**

​		**11.3 对axios还不太熟，也可参考git或npm官网中的axios文档。**

```js
//利用axios对axios进行二次封装
//故先引入axios
import axios from 'axios'

//1.利用axios对象的方法create，创建一个axios实例
//2.request就是axios，但需要稍微进行配置。
const requests = axios.create({
    //配置对象
    //baseURL基础路径，发请求时，路径当中会出现api
    baseURL: "/api",
    //timeout代表请求超时的时间
    timeout: 5000,
});

//请求拦截器：可以在发请求之前，可处理一些业务。
requests.interceptors.request.use((config) => {
    //config:配置对象，对象中有一个属性很重要(即：headers请求头)
    return config;
})

//响应拦截器
requests.interceptors.request.use((res) => {
    //响应成功的回调函数：服务器响应数据回来之后，响应拦截器可检测到，可做一些事情
    return res.data;
}, (error) => {
    //响应失败的回调函数
    return Promise.reject(new Error('faile'));
});


//对外暴露
export default requests;
```





## 12. API接口统一管理

**当项目很小时：**完全可以在组件的生命周期函数中发请求。

**当项目很大时：**axios.get('xxx')

### 		**12.1 跨域问题**

**(服务器与服务器之间是没有跨域问题的，只有浏览器与浏览器之间才有)**

什么是跨域：协议、域名、端口号不同请求，称之为跨域。

eg：http://localhost:8080/#/home



`webpack.config.js`文件实质就是`vue.config.js`



`target`是要获取的那台服务器的IP地址

### 		**12.2 面试易遇到的问题：（需自己复习一下）**

​		**问题一：跨域问题，跨域是什么？**

​		**答：**协议、域名、端口号不同请求，称之为跨域。

​		**问题二：跨域的解决方案是什么？**

​		**答：**JSONP方法、CROS方法、代理(Proxy)方法【较为常用】





## 13. nprogress进度条的使用

​		安装nprogress：`npm install --save nprogress`

​		**13.1 **

**start：进度条开始**

**done：进度条结束**

进度条的颜色可修改，在它的修改样式中修改即可。

在`api`文件夹里的`request.js`文件中写：

```js
//利用axios对axios进行二次封装
//故先引入axios
import axios from 'axios'
//①.引入进度条
import nprogress from 'nprogress';
// console.log(nprogress)，输出的内容其中start:表示进度条开始；done:表示进度条结束
//②.引入进度条样式
import "nprogress/nprogress.css";

//1.利用axios对象的方法create，创建一个axios实例
//2.request就是axios，但需要稍微进行配置。
const requests = axios.create({
    baseURL: "/api",
    timeout: 5000,
});

requests.interceptors.request.use((config) => {
    nprogress.start() //③.进度条开始动
    return config;
})

//响应拦截器
requests.interceptors.response.use((res) => {
    nprogress.done() //③.进度条结束
    return res.data;
}, (error) => {
    return Promise.reject(new Error('faile'));
});

//对外暴露
export default requests;
```





## 14. Vuex状态管理库

### **14.1 vuex是什么？**

是官方提供的一个插件，状态管理库，集中式管理项目中组件共用的数据。

但并不是全部项目都需要Vuex，若项目很小，完全不需要；若项目很大、组件很多、数据很多，数据维护很费劲，则需要使用Vuex。**Vuex可以模块化开发。**

​		安装Vuex：`npm install --save vuex`

**● 配置仓库Vuex：**在src文件夹下新建一个`store`的文件夹，再里面再建一个index.js文件。

### **14.2 Vuex的四个大核心概念：**

​	**state**：仓库存储数据的地方。

​		`const state = {};`

​	**mutation**：修改state的唯一手段。

​		`const mutations = {};`

​	**action**：处理action，可书写自己的的业务逻辑，也可处理异步。

​		`const actions = {};`

​	**getters**：理解为计算属性，用于简化仓库数据，让组件获取仓库的数据更加方便。

​		`const getters = {};`

**● 在入口文件main.js中引入建好的仓库**

**● 在使用到该仓库的组件中，引入{mapState} from 'vuex'映射为组件身上的数组。**

**● 三连环：在actions里面提交mutations，让mutations进来修改state。**

### 14.3 this.$state.dispatch与this.$state.commit的主要区别：

**dispatch**：含有异步操作，数据提交至 **<strong style="color:red">actions</strong>** ，可用于向后台提交数据。

`this.$store.dispatch('action', payload);`

**commit**：同步操作，数据提交至 **<strong style="color:red">mutations</strong>** ，可用于读取用户信息写到缓存里。

`this.$store.commit('add',1);`

### 14.4 vuex实现模块式开发

项目很大、组件很多、数据很多，数据维护很费劲，则需要使用Vuex，Vuex可以模块化开发**(把大仓库变成小仓库，按模块式进行存储)**。

1.可以给每一个组件模块来一个小仓库。

2.将每个小仓库引入到store文件夹里的index.js(大仓库)中，用modules对外暴露，实现Vuex仓库模块式开发存储数据。





# Day3

## 15. 完成TypeNav三级联动展示数据业务

前提已经将axios二次封装好了，vuex也准备好了，vuex中的模块化也准备好了。

**注：项目中所有的全局组件的文件最好都放在components文件夹中**

state  相当于  data(){return{}} 区域定义属性;

mutations 相当于 created() 或 mounted() 调用方法;

actions 相当于 methods 定义方法；

getters 相当于 computed  是为了简化数据而生的。

**要练就一眼识别几层分类的思想**





## 16. 完成三级联动动态背景颜色

**方法一：**写css样式

```css
	.item:hover{
		background:skyblue;
	}
```

**方法二：**写js

```html
     <template>
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        ......
           <h3 @mouseenter="changeIndex(index)">
        ......
       </div>
     </template>
     <script>
     ......
	  methods: {
	    //鼠标进入修改响应式数据currentIndex属性
	    changeIndex(index) {
  	    //index：鼠标移上某一个一级分类的元素的索引值
    	  this.currentIndex = index;
   		 },
   		//一级分类鼠标移除的事件回调
	    leaveIndex(){
	      //鼠标移除currentIndex，变为-1
  	    this.currentIndex = -1;
  		 }
	  },
     ......
     </script>
```

**通过js动态去控制二、三级分类的隐藏和显示业务**

二、三级分类应有一个动态的样式，动态地显示和隐藏。

**判断条件:**只要谁有类名，谁就应该显示；currentIndex是否等于当前的索引值index。

`:style="{display:currentIndex==index?'block':'none'}"`

代码如下：

```html
<template>
	......
	  <!-- 事件委派|事件代理 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <!-- 三级联动 -->
        <div class="sort">
        ......
        	<!-- 二级、三级分类 -->
        	<div class="item-list clearfix"  :style="{display:currentIndex==index?'block':'none'}">
	......
</template>
```

 



## 17. 函数的防抖与节流

### 17.1卡顿现象引入函数的防抖与节流

**● 卡顿：** 由于用户的行为过快，导致浏览器反应不过来。若当前回调函数中有一些大量业务，则可能出现卡顿现象。

   **○ 正常情况下(用户慢慢操作)：**鼠标一进入每一个一级分类的h3，触发鼠标进入事件，可正常执行。

   **○ 非正常情况下(用户操作过快)：**本身全部的一级分类都应该触发鼠标进入事件，但经测试，只有部分h3触发了。

**● 节流：**在规定的间隔时间范围内不会重复触发回调，只有大于这个事件间隔才会触发回调，**把频繁触发变为少量触发**。

**● 防抖：**前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，**即若连续快速地触发，也只会执行最后一次**。

### 17.2函数防抖的理解

**● 防抖**：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，**即若连续快速地触发，也只会执行最后一次**。

安装lodash.js：`npm install --save lodash`

用代码：

```js
input.oninput = _.debounce(function() {
      console.log('ajax发请求')
 }, 1000)`
```

进行使用：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>防抖</title>
    <!-- 引入lodash：lodash全部的功能引入 -->
    <script src="js/lodash.js"></script>
</head>

<body>
    <p>
        请输入搜索内容：<input type="text">
    </p>
</body>

</html>

<script>
    //防抖：前面的所有触发都被取消，最后一次执行在规定时间之后才会触发，即若连续快速的触发，只会执行一次。
    let input = document.querySelector('input');
    //文本发生变化立即执行
    /*     input.oninput = function() {
            console.log('ajax发请求')
        } */

    input.oninput = _.debounce(function() {
            console.log('ajax发请求')
        }, 1000)
        //lodash插件：里面封装函数的防抖与节流的业务【闭包+延迟器】
        //1.lodash函数库对外暴露的是_函数
</script>
```



### 17.3函数节流的理解

**● 节流：**在规定的间隔时间范围内不会重复触发回调，只有大于这个事件间隔才会触发回调，**把频繁触发变为少量触发，使浏览器有充分时间解析代码**。

安装lodash.js：`npm install --save lodash`

用代码：

```js
    button.onclick = _.throttle(function() {
        //节流：目前这个回调函数5s执行一次
        //加入这里有很多的业务代码，是可以给浏览器充裕的时间进行解析的。
        count++;
        span.innerHTML = count;
        console.log('执行');
    }, 5000);
```

进行使用：

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>节流</title>
    <!-- 引入lodash：lodash全部的功能引入 -->
    <script src="js/lodash.js"></script>

</head>

<body>
    <div>
        <h1>我是计数器<span>0</span></h1>
        <button>点我加一</button>
    </div>
</body>

</html>

<script>
    //节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个事件间隔才会触发回调，把频繁触发变为少量触发。
    //获取节点
    let span = document.querySelector('span');
    let button = document.querySelector('button');
    let count = 0;
    //计数器：在一秒以内，数字只能加上1
    button.onclick = _.throttle(function() {
        //节流：目前这个回调函数5s执行一次
        //加入这里有很多的业务代码，是可以给浏览器充裕的时间进行解析的。
        count++;
        span.innerHTML = count;
        console.log('执行');
    }, 5000);
</script>
```





## 18. 三级联动

### 18.1三级联动中的节流

**throttle回调函数别用箭头函数，否则可能出现上下文this的问题。**

```js
......
methods: {
..........
      changeIndex:throttle(function(index) {
      //index：鼠标移上某一个一级分类的元素的索引值  
      this.currentIndex = index;
    },50),
          .......
}
......
```

### 18.2三级联动中的路由跳转分析

三级联动用户的分类：一级分类、二级分类、三级分类

Home模块跳转到Search模块，一级会把用户选中的产品（产品名字、产品ID）在路由跳转的时候进行传递。

**路由跳转的两种方式：**

①.**声明式导航：**router-link

​		在本次项目中，router-link容易出现卡顿问题。

②.**编程式导航：**push|replace

​		本次较为好的办法使用的就是编程式导航。

​		用**编程式导航 + 事件的委派**

```html
<template>
......
	<div class="all-sort-list2" @click="goSearch">
	......
    </div>
......
</template>
...............

<script>  
......
methods{
......
   //进行路由跳转的方法
    goSearch(){
      //最好的解决方案：编程式导航 + 事件委派
      //利用事件委派存在一些问题：①.点击的不一定都是a标签    ②.如何获取参数【产品名、产品id】
    }
......
}
......
</script>  
```

### 18.3 完成三级联动的路由跳转与传递参数的业务

利用了**自定义属性**解决，区分是否为a标签、区分是否为一级、二级、三级标签

```html
<template>
    ........
              <h3 @mouseenter="changeIndex(index)">
                <a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId">{{ c1.categoryName }}--{{ index }}</a>
              </h3>
              <!-- 二级、三级分类 -->
              <div class="item-list clearfix"  :style="{display:currentIndex==index?'block':'none'}">
                <!-- 因为:Key里已经有categoryId了，所以不用写index -->
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId">{{ c2.categoryName }}--{{ index }}</a>
                    </dt>
                    <dd>
                      <em v-for="c3 in c2.categoryChild" :key="c3.categoryId">
                        <a :data-categoryName="c3.categoryName" :data-category3Id="c3.categoryId">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
    ........
</template>
<script>
    ........
        goSearch(event){
      //最好的解决方案：编程式导航 + 事件委派
      //利用事件委派存在一些问题：①.点击的不一定都是a标签    ②.如何获取参数【产品名、产品id】
      // this.$router.push('/search')
      let element = event.target;
      console.log(element)
      //获取到当前触发这个事件的节点【h3、a、dt、dl】，需带有data-categoryname这样的节点【一定是a标签】
      //节点有一个属性dataset属性，可获取节点的自定义属性与属性值。
      
      // 通过categoryname区分是否为a标签，通过category1id,category2id,category3id区分是否为一级、二级、三级标签
      let {categoryname,category1id,category2id,category3id} = element.dataset;
      //如果标签身上拥有categoryname，则一定是a标签
      if(categoryname){
        //整理路由跳转的参数
        let location = {name:"search"}
        let query = {categoryname:categoryname}
        //一级分类、二级分类、三级分类
        if(category1id){
          query.category1Id =category1id;
        }else if(category2id){
          query.category2Id =category2id;
        }else if(category3id){
          query.category3Id =category3id;
        }
        //整理完参数
        // console.log(location,query)
        location.query=query;

        //将其加入路由跳转
        this.$router.push(location);
      } 
    }
    ........
</script>
```



# 复习一(有常见的面试题)

**1).**商品分类的三级列表由静态变为动态形式，需要向服务器发ajax。

​	【获取服务器数据：需解决跨域问题【目前知道的三种(往上找)】】

**2).**函数的防抖与节流【该类问题面试频率较高】

**3).**路由跳转：

​		①.声明式导航(router-link)

​				声明式导航是一个组件，组件都是vue component类的一个实例。所以如果需要一下子创建很多组件，则会造成卡顿。

​		②.编程式导航

​				本次项目采用的是编程式导航+委派来解决问题；同时也利用了自定义属性(需复习)。





# Day4 

## 19.Search模块

### 		19.1 Search模块商品模块分类与过渡动画

全局组件直接使用，不需引用

1).判断是否为某个路由组件(可用路径判断)

```html
<templayte>
......
   	<div @mouseleave="leaveShow" @mouseenter="enterShow">
	......
	</div>
......
</templayte>
......
<script>
......
    //当鼠标移入时，让商品分类列表进行展示
    enterShow(){
      if(this.$route.path !="/home"){
      this.show = true
      }
    },

    //当鼠标离开时，让商品分类列表进行隐藏
    leaveShow(){
      this.currentIndex = -1
      if(this.$route.path !="/home"){
      this.show = false
      }
    }
......
</script>
```



过渡动画：

```css
<template>
......
	<!-- 过渡动画 -->
	<transition name="sort">
		..........
	</transition>
......
</template>

<script>
	//过渡动画的的样式
    //过渡动画开始状态（进入）
    .sort-enter{
      height: 0px;
    }
    //过渡动画结束状态（进入）
     .sort-enter-to{
      height: 461px;
    } 
    //定义动画事件、速率
    .sort-enter-active{
      overflow: hidden;//溢出文字的隐藏
      transition: all .5s linear;
    } 
</script>
```



Search模块中 typeNav商品分类菜单（过渡动画效果）

**过渡动画：**前提组件、元素务必要有v-if或v-show指令才可以进行过渡动画。

### 		19.2 typeNav商品分类列表的优化

在App.vue文件中

```js
 mounted(){//这里的mounted只会执行一次，可把重复执行的，且只需执行一次即可的内容提前到这里写。

  //通知Vuex发请求，获取数据，存储于仓库当中。
  //派发一个action，获取商品分类的三级列表数据
 this.$store.dispatch("categoryList");

 }
```

### 		19.3 合并query和params参数

**如果有query没有params：**

```js
        if(this.$route.params){
          location.params = this.$route.params;
          //动态给location配置对象添加query属性
          location.query = query
          //将其加入路由跳转
          this.$router.push(location);
        }
```

**如果有params没有query：**

```js
      if(this.$route.query){
        let location ={name:"search",params:{keyword:this.keyword || undefined}};
        location.query = this.$route.query;
        this.$router.push(location);
      }
```

### 19.4 mockjs模拟数据

mock只在前端页面生成数据，不会向后端发送请求。

安装：`npm install --save mockjs`

**使用步骤：**

​	1). 在项目中，src文件夹中创建mock文件夹。api文件夹中利用axios对axios进行二次封装，路径baseURL的值记得要更改，这里按需改成了/mock。

​	2). 准备JSON数据（在mock文件夹仲创建相应的JSON文件）————格式化一下，别留空格。

​	3).把mock数据需要的图片放置到public文件夹中【public文件夹在打包时，会把相应的资源原封不动打包到dist文件夹中】

​	4).创建mockServe.js通过mockjs插件实现模拟数据。

​	5).mockServer.js文件需要在入口文件main.js中引入（至少需要执行一次，才能模拟数据）。

**webpack默认对外暴露的有：图片、JSON数据格式**

### 19.5 获取banner轮播图的数据

**用上了vuex中的三连环**

①.在`store文件夹`里的`home文件`中使用vuex三连环

```js
//引入API
import {reqGetBannerList } from '@/api/index'
//home模块的小仓库
//vuex的四大核心概念必须要有
const state = {
    //state中数据的默认初始值是【根据接口返回值初始化的】，服务器返回对象则state默认值为空对象，服务器返回数组则state默认值返回空数组。
    getBannerList: []
};
const mutations = {
    GETBANNERLIST(state, getBannerList) {
        state.getBannerList = getBannerList
    }
};
const actions = {
    //三级联动，通过API里面的接口函数调用，向服务器发请求，获取服务器的数据。
    //获取首页轮播图的数据
    async getBannerList({ commit }) {
        const result2 = await reqGetBannerList();
        if (result2.code == 200) {
            commit('GETBANNERLIST', result2.data)
        }
    }
};
const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```

②.在`ListContainer文件`中添加computed方法

```js
  computed:{
    ...mapState({
      bannerList:state=>state.home.getBannerList
    })
  }
```



## 20. swiper的基本使用

https://www.swiper.com.cn/api/start/new.html在其中打开使用文档进行阅读使用

使用步骤：

1).加载插件,引入js和css包。

2).在newSwiper实例之前，页面中的结构必须要先提前准备好。

3).(页面中务必要有结构)  new Swiper(swiperContainer, parameters)；第一个参数可以是字符串，也可以是真实的DOM节点

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 第一步：加载插件,引入js和css包 -->
    <script src="js/swiper.min.js"></script>
    <!-- <script src="css/swiper.min.css"></script> -->
    <link rel="stylesheet" href="css/swiper.min.css">

</head>
<!--第二步：在newSwiper实例之前，页面中的结构必须要先提前准备好。-->
<body>
    <div class="swiper-container">
        <div class="swiper-wrapper">
            <div class="swiper-slide">Slide 1</div>
            <div class="swiper-slide">Slide 2</div>
            <div class="swiper-slide">Slide 3</div>
        </div>
        <!-- 如果需要分页器 -->
        <div class="swiper-pagination"></div>

        <!-- 如果需要导航按钮 -->
        <div class="swiper-button-prev"></div>
        <div class="swiper-button-next"></div>

        <!-- 如果需要滚动条 -->
        <div class="swiper-scrollbar"></div>
    </div>
</body>

</html>

<script>
    //第三步：(页面中务必要有结构)  new Swiper(swiperContainer, parameters)；第一个参数可以是字符串，也可以是真实的DOM节点
    //有dom了才能new
    // 写法一：
    // var mySwiper = new Swiper('.swiper-container', {
    // 写法二：     new Swiper(swiperContainer, parameters)；第一个参数可以是字符串，也可以是真实的DOM节点
    var mySwiper = new Swiper(document.querySelector('.swiper-scrollbar'), {
        // direction: 'vertical', // 垂直切换选项
        loop: true, // 是否为循环模式选项

        // 如果需要分页器
        pagination: {
            el: '.swiper-pagination',
        },

        // 如果需要前进后退按钮
        navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
        },

        // 如果需要滚动条
        scrollbar: {
            el: '.swiper-scrollbar',
        },
    })
</script>
<style>
    .swiper-container {
        width: 400px;
        height: 200px;
    }
</style>
```

### 20.1 Banner实现轮播图的第一种方法

安装：`npm install --save swiper`

在`ListContainer文件夹`下的`index.vue`中的mouted(){}里写一个定时器函数（不是最好的办法，但能解决问题）。

```vue
<script>
......
	    setTimeout(() => {
      var mySwiper = new Swiper(document.querySelector(".swiper-container"), {
        loop: true, // 循环模式选项

        // 如果需要分页器
        pagination: {
          el: ".swiper-pagination",
          clickable :true,//分液器小球是否能够翻页
        },

        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },

        // 如果需要滚动条
        scrollbar: {
          el: ".swiper-scrollbar",
        },
      });
    },1000);
......
</script>
```

此时不推荐用updata，因为若有其他数据刷新时，会重新new Swiper。









## 21. 轮播图通过watch+nectTick解决问题

**①若只用watch**

```vue
<script>
......
watch:{
	handler(newValue,oldValue){
        //通过watch箭筒bannerList属性的属性值变化。若执行handler方法，代表组件实例身上这个属性的属性已经有了【数组：四个元素（仓库两个，ListContainer有两个）】
        //当这个函数执行，只能保证bannerList数据已经有了，但是没法办证v-for是否执行结束。
        //当v-for执行完毕，才会有结构【但是单纯在watch中使没法保证的】
	      var mySwiper = new Swiper(document.querySelector(".swiper-container"), {
        loop: true, // 循环模式选项

        // 如果需要分页器
        pagination: {
          el: ".swiper-pagination",
          clickable :true,//分液器小球是否能够翻页
        },

        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      });
	}
}
......
</script>
```



**②用watch+neckTick（较为完美的解决方案）**

> **neckTick：**
>
> **1.可在下次DOM更新，<strong style="color:red">循环结束之后(这里就可以指的是v-for结束后)，执行延迟回调。</strong>或者说，在<strong style="color:red">修改数据之后，立即使用这个方法</strong>，获取更新后的DOM。**
>
> **2.可保证页面中的结构一定是存在了的，neckTick经常和很多插件一起使用【因为大多差价DOM是存在的】**

```vue
<script>
......
  watch: {
    bannerList: {
      handler(newValue, oldValue) {
        //通过watch箭筒bannerList属性的属性值变化。若执行handler方法，代表组件实例身上这个属性的属性已经有了【数组：四个元素（仓库两个，ListContainer有两个）】
        //当这个函数执行，只能保证bannerList数据已经有了，但是没法办证v-for是否执行结束。
        //当v-for执行完毕，才会有结构【但是单纯在watch中使没法保证的】
        this.$nextTick(() => {
          // 当执行这个回调时，保证服务器数据回来了，v-for执行完毕了【所以轮播图的结构一定有了】
          var mySwiper = new Swiper(
            document.querySelector(".swiper-container"),
            {
              loop: true, // 循环模式选项

              // 如果需要分页器
              pagination: {
                el: ".swiper-pagination",
                clickable: true, //分液器小球是否能够翻页
              },

              // 如果需要前进后退按钮
              navigation: {
                nextEl: ".swiper-button-next",
                prevEl: ".swiper-button-prev",
              },
            }
          );
        });
      },
    },
  },
......
</script>
```

# 复习二

1).完成商品分类的三级列表路由跳转一级路由传参（合并参数）。

2).完成search模块中对于typeNav使用（过渡动画）

3).对于typeNav请求次数也进行优化

4).swiper插件

swiper插件：经常制作轮播图（可用于移动端，也可用于PC端）

​		使用步骤：

​			①.引入相应依赖包（swiper.js和swiper.css）。

​			②.页面中的结构务必要有。

​			③.初始化swiper实例，给轮播图添加动态效果。

5).mock数据，通过mockjs模块实现的。

6).用watch+neckTick解决轮播图



# Day5

## 22. 获取Floor组件mock数据

getFloorList这个action是要在Home路由组件发，而不能在Floor组件中发，因为需要v-for遍历组件。

v-for也可以在自定义标签中使用。

### 22.1 组件通信的方式有哪些？【面试频率极高，要记得！】

**props：**用于父子组件通信

**自定义事件：**@on   @emit  可实现子给父通信

**全局事件总线：**$bus （全能的）

**插槽**

**vuex**

pubsub-js：全能，但是vue中几乎不用

### 22.2 动态展示Floor组件

Floor是Home的子组件。先用props进行父子组件通信。

动态传递数据。

运用swiper进行轮播图的修改。

> 在ListContainer组件中的轮播图，因为当时组件是由内部发请求、动态渲染结构【前台服务器数据需要传回来】，所以ListContainer组件中的轮播图，要把mounted写在外面的(写在了App.vue里)，所以这里在ListContainer组件mounted之前结构还没有。

Floor这个组件，是在Home组件里发的请求，数据是父组件给的，子组件已经渲染了，所以说在Floor组件mounted之前结构就已经有了。

**Home文件下的Floor文件**

```vue
<template>
  <!--楼层-->
  <div class="floor">
    <div class="py-container">
      <div class="title clearfix">
        <h3 class="fl">{{ list.name }}</h3>
        <div class="fr">
          <ul class="nav-tabs clearfix">
            <li class="active" v-for="(nav,index) in list.navList" :key="index">
              <a href="#tab1" data-toggle="tab">{{nav.text}}</a>
            </li>
          </ul>
        </div>
      </div>
      <div class="tab-content">
        <div class="tab-pane">
          <div class="floor-1">
            <div class="blockgary">
              <ul class="jd-list">
                <li v-for="(keyword, index) in list.keywords" :key="index">
                  {{ keyword }}
                </li>
              </ul>
              <img :src="list.imgUrl" />
            </div>
            <div class="floorBanner">
              <!-- 轮播图 -->
              <div class="swiper-container" ref="floor1Swiper">
                <div class="swiper-wrapper">
                  <div
                    class="swiper-slide"
                    v-for="(carousel, index) in list.carouselList"
                    :key="carousel.id"
                  >
                    <img :src="carousel.imgUrl" />
                  </div>
                </div>
                <!-- 如果需要分页器 -->
                <div class="swiper-pagination"></div>

                <!-- 如果需要导航按钮 -->
                <div class="swiper-button-prev"></div>
                <div class="swiper-button-next"></div>
              </div>
            </div>
            <div class="split">
              <span class="floor-x-line"></span>
              <div class="floor-conver-pit">
                <img :src="list.recommendList[0]" />
              </div>
              <div class="floor-conver-pit">
                <img :src="list.recommendList[1]" />
              </div>
            </div>
            <div class="split center">
              <img :src="list.bigImg" />
            </div>
            <div class="split">
              <span class="floor-x-line"></span>
              <div class="floor-conver-pit">
                <img :src="list.recommendList[2]" />
              </div>
              <div class="floor-conver-pit">
                <img :src="list.recommendList[3]" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import Swiper from "swiper";
export default {
  name: "Floor",
  props: ["list"],
  //new 一个swiper
  mounted() {
    var mySwiper = new Swiper(
      this.$refs.floor1Swiper,
      // document.querySelector(".swiper-container"),
      {
        loop: true, // 循环模式选项

        // 如果需要分页器
        pagination: {
          el: ".swiper-pagination",
          clickable: true, //分液器小球是否能够翻页
        },

        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
      }
    );
  },
};
</script>
```

### 22.3 共用组件Carsouel

将首页Home组件里的轮播图（在Floor组件和ListContainer组件中）功能拆出来，新建成一个共用全局组件。

**注：若看到某个组件在很多地方使用，则可把它变成全局组件。注册一次，即可在任意地方使用，共用的组件或非路由组件应放在components文件夹中。**



## 23. Search模块的静态组件

### 23.1 写一个模块的步骤（套路）：

**1).先写静态页面 + 将静态组件拆分出来**

**2).写接口，发请求（API）**

**3).vuex（三连环）**【要求很熟练】

**4).组件获取仓库数据，动态展示数据**

### 23.2 箭头函数

()中定义参数，若只有一个参数，可以不写括号；

{}中写函数体，若函数体找那个只有返回值，可不写return。

**箭头函数vs普通函数**

1).this指向不同

2).普通函数：谁调用这个函数，this就指向谁。

3).箭头函数：在哪里定义函数，this就指向谁。

## 24. search模块中动态展示产品列表

**1).先写静态页面 + 将静态组件拆分出来**

**2).写接口，发请求（API）**

**3).vuex（三连环）**【要求很熟练】

**4).组件获取仓库数据，动态展示数据**

**一). api文件夹下的index.js**

```js
import requests from "./request";

//获取search模块数据    地址：/api/list  请求方式为：post   这里需要带参数
//当前这个函数也需要接收外部传递参数
//当给这个接口获取搜索模块的数据，给服务器传递一个默认参数【传递的参数至少是一个空对象】

export const reqGetSearchInfo = (params) => requests({ url: "/list", method: "post", data: params })
```

**二). 在仓库store文件夹下的index.js**

```js
//引入API
import { reqGetSearchInfo } from '@/api'
//search模块的小仓库
//vuex的四大核心概念必须要有
const state = {
    searchList: {}
};
const mutations = {
    GETSEARCHLIST(state, searchList) {
        state.searchList = searchList
    }
};
const actions = {
    //获取search模块数据
    async getSearchList({ commit }, params = {}) {
        //当前reqGetSearchInfo这个函数在调用获取服务器数据时，至少传递一个参数（空对象）
        // `this.$store.dispatch('action', payload);`
        //params形参：当用户派发action时，当第二个参数传递过来时，至少是一个空对象。
        let result4 = await reqGetSearchInfo(params);
        if (result4.code == 200) {
            commit("GETSEARCHLIST", result4.data);
        }
    }
};

//计算属性
//项目当中getters主要的作用：简化仓库中的数据。
const getters = {
    //当前的state是小仓库search里的state，并非大仓库中的那个state。
    goodsList(state) {
        //这样书写是会有问题的。
        //若网络不给力或没有网络，则state.searchList.goodsList应返回的是undefined；所以此时计算新的属性的属性值至少给一个数组。
        return state.searchList.goodsList || [];
    },
    trademarkList(state) {
        //这样书写是会有问题的
        return state.searchList.trademarkList;
    },
    attrsList(state) {
        //这样书写是会有问题的
        return state.searchList.attrsList;
    },

}

export default {
    state,
    mutations,
    actions,
    getters
}
```

**三). 在路由pages文件夹下的Search文件中的index.js**

```html
<template>
......
</template>
<script>
......
  computed:{
    ...mapGetters(['goodsList'])
  }
......
</script>
```



### 24.1 Search模块中子组件动态开发

将重复的、可使用v-for的部分使用起来。

本次所使用的数据在store仓库文件夹下的search文件夹里。Search模块的子组件SearchSelector.vue进行引入使用。

```vue
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <li v-for="(trademark,index) in trademarkList" :key="trademark.tmId">{{trademark.tmName}}</li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <div class="type-wrap" v-for="(attr,index) in attrsList" :key="attr.ttrId">
      <div class="fl key">{{attr.attrName}}</div>
      <div class="fl value">
        <ul class="type-list">
          <li v-for="(attrvalue,index) in attr.attrValueList" :key ="index">
            <a>{{attrvalue}}</a>
          </li>

        </ul>
      </div>
      <div class="fl ext"></div>
    </div>

  </div>
</template>

<script>
  import {mapGetters} from 'vuex'; 
  export default {
    name: 'SearchSelector',
    computed:{
      ...mapGetters(['trademarkList','attrsList'])
    }
  }
</script>
```

# 复习三

**前端三个重要的原理：轮播图(Carousel)、分页器(Pagination)、日历**

1).search模块需要的服务器数据，已经请求到了，而且存储于vuex仓库中，而且有一些数组数据【已经通过getters】进行简化（getters简化数据而生）。

2).商品列表、平台售卖属性的动态数据（来自服务器的数据）。

# Day6

## 25. Object.assign的用法

为了再次发请求得到不同数据，可以用watch数据监听。

**Object.assign的用法: Object.assign(target, …sources)**

**target: 目标对象,sources: 源对象**

用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，并将返回目标对象。

```js
const o1 {a:1};
const o2 {b:2};
const o3 {c:3};

const obj = Object.assign(o1,o2,o3);
console.log(obj);//{a:1,b:2,c:3}
console.log(o1);//{a:1,b:2,c:3}，目标对象自身也会改变
```



## 26. 面包屑

### 26.1 面包屑处理分类的操作

用的是编程式路由导航【在自己的路由组件下跳转到自己】

```js
<template>
......
<!-- 分类的面包屑 -->
	      <ul class="fl sui-tag">
            <li class="with-x" v-show="searchParams.categoryname">
              {{ searchParams.categoryname
              }}<i @click="removeCategoryname">×</i>
            </li>
          </ul>
......
</template>

<script>
......
	removeCategoryname() {
      //把带给服务器是参数置空了，还要向服务器发请求。
      //带给服务器参数说明可有可无的：若属性值为空的字符串还是会把相应的字段带给服务器。
      //但是把相应的字段变为undefined，则当前这个字段不会带给服务器。
      this.searchParams.categoryname = undefined;
      this.searchParams.category1Id = undefined;
      this.searchParams.category2Id = undefined;
      this.searchParams.category3Id = undefined;
      this.getData();
      //地址栏也需要修改，进行路由跳转(在自己的路由组件下跳转到自己)
      this.$router.push({name:"search"});

    },
......
</script>
```

地址栏也需要进行路由跳转(在自己的路由组件下跳转到自己):` this.$router.push({name:"search"});`

**严谨一点儿的写法：**

```js
    removeCategoryname() {
      this.searchParams.categoryname = undefined;
      this.searchParams.category1Id = undefined;
      this.searchParams.category2Id = undefined;
      this.searchParams.category3Id = undefined;
      this.getData();// 可要可不要
      //地址栏也需要修改，进行路由跳转(在自己的路由组件下跳转到自己)
      if(this.$route.params){
          this.$router.push({name:"search",params:this.$route.params});
      }
```

### 26.2 面包屑处理关键字的操作

当Search组件中的面包屑关键字清除后，需要让兄弟组件Header组件中的关键字清除。

**<strong style = "color:red">组件通信方法：</strong>**

​	**props：**（父给子）

​	**插槽：**（父给子）

​	**自定义事件：**（子给父）

​	**vuex：**（万能的方法，该方法可以用兄弟之间，但是本次项目用来当仓库数据）

​	**$bus：**（万能的方法，全局事件总线）

​	**pubsub-js：**（万能的方法，但是在vue中用得少）

```html
<template>
......
		  <ul>
            <!-- 关键字的面包屑 -->
            <li class="with-x" v-show="searchParams.keyword">
              {{ searchParams.keyword }}<i @click="removeKeyword">×</i>
            </li>
          </ul>
......
</template>

<script>
        //删除关键字的面包屑的名字
    removeKeyword() {
      this.searchParams.keyword = undefined;
      //再次发请求
      this.getData();
      //通知兄弟组件Header清除关键字，发送清除请求
      this.$bus.$emit("clear");
      if (this.$route.query) {
        this.$router.push({ name: "search",query:this.$route.query});
      }
    },
</script>
```

此时运用了全局事件总线`$bus`，所以应在`main.js`入口文件中进行补写全局事件总线$bus配置：

```js
    //全局事件总线$bus配置
    beforeCreate() {
        Vue.prototype.$bus = this;
    },
```

在`Header文件夹下的index.vue`中补mounted的全局事件总线`$bus`：

```js
  mounted(){
    //通过全局事件总线$bus清除关键字
    this.$bus.$on("clear",()=>{
      this.keyword = '';
    });
  },
```

### 26.3 面包屑处理品牌信息

**<strong style = "color:red">组件通信方法：</strong>**

​	**1.props：**（父给子）

​	**2.插槽：**（父给子）

​	**3.自定义事件：**（子给父）

​	**4.vuex：**（万能的方法，该方法可以用兄弟之间，但是本次项目用来当仓库数据）

​	**5.$bus：**（万能的方法，全局事件总线）

​	**6.pubsub-js：**（万能的方法，但是在vue中用得少）



此时用的是自定义事件

**首先：**在Search中的子组件SearchSelector展示标签里，用**@**定义自定义事件：

```html
<template>
	<SearchSelector @trademarkInfo="trademarkInfo"/>
    </template>
```



```html
<methods>
	//自定义事件回调
    trademarkInfo(){},
</methods>
```

**其次：**在SearchSelector.vue中用**this.$emit('trademarkInfo',trademark);**发送请求给Search组件

```html
<template>
    ......
		<li v-for="(trademark,index) in trademarkList" :key="trademark.tmId" @click="tradeMarkHandler(trademark)">{{trademark.tmName}}</li>
	......
</template>
<script>
	......
        methods:{
      //品牌的事件处理函数
      tradeMarkHandler(trademark){
        //点击了品牌（苹果），还需要整理参数，向服务器发请求获取相应的数据进行展示。
        // alert('123')
        //因为是由父组件中的searchParams参数带给服务器参数的，所以子组件把被点击的品牌的信息传给父组件，父组件再与服务器联系。
        this.$emit('trademarkInfo',trademark);
      }
    }
    ......
</script>
```

**再次：**修改、补充Search模块里的内容

```html
<template>
    ......
    	   <ul>
            <!-- 品牌点击的面包屑 -->
            <li class="with-x" v-if="searchParams.trademark">
              {{ searchParams.trademark.split(":")[1]
              }}<i @click="removeTradeMark">×</i>
            </li>
          </ul>
    ......
</template>
<Script>
    ......
      //自定义事件回调
      trademarkInfo(trademark) {
      // console.log("信息",trademark)
      // 1.整理品牌字段的参数   “ID:品牌名称”
      this.searchParams.trademark = `${trademark.tmId}:${trademark.tmName}`;
      // 再次发请求获取search模块最新列表数据进行展示
      this.getData();
    },
    //删除品牌的信息
    removeTradeMark() {
      this.searchParams.trademark = undefined;
      //再次发请求
      this.getData();
      //老师使用的是v-if，所以当trademark为undefined时，不会解析if内部结构，故不会报错。而实测v-show会报错,Cannot read property 'split' of undefined"
    },
    ......
</Script>
```



## 27.平台售卖属性的操作

### 27.1 子组件传给父组件（用自定义事件）

首先在`Search`的子组件`SearchSelector组件`中补充自定义事件`@click="attrInfo(attr,attrvalue)"`和`attrInfo`的方法：

```vue
<template>
......
	<li v-for="(attrvalue,index) in attr.attrValueList" :key ="attrvalue" @click="attrInfo(attr,attrvalue)">
            <a>{{attrvalue}}</a>
    </li>
......
</template>
<script>
    methods:{
        ......
        attrInfo(attr,attrValue){
        //["属性ID:属性值:属性名"];
        this.$emit("attrInfo",attr,attrValue);
      }
        ......
    }
</script>
```

其次在`Search组件`中补充：`@attrInfo="attrInfo"`和方法`attrInfo(attr,attrValue)`，即可。

```html
<template>
    ......
<!--selector  Search的子组件-->
<SearchSelector @attrInfo="attrInfo"/>
    ......
</template>
......
<script>
  methods:{
    ......
    //收集平台属性地方回调函数（自定义事件）
    attrInfo(attr,attrValue){
      // ["属性ID:属性值:属性名"]
      console.log(attr,attrValue);
    }
    ......
  }
</script>
```

### 27.2 将平台售卖属性放置面包屑(数组去重)

需要遍历，所以用v-for，而不用v-if。

在Search组件中整理好数据、增加`平台的售卖属性值的面包屑`：

```html
<template>
    ......
                <!-- 平台的售卖属性值的面包屑 -->
            <li class="with-x" v-for="(attrValue,index) in searchParams.props" :key="index">
              {{ attrValue.split(":")[1]}}<i @click="removeTradeMark">×</i>
            </li>
    ......
</template>
<script>
......
    //收集平台属性地方回调函数（自定义事件）
    attrInfo(attr, attrValue) {
      // ["属性ID:属性值:属性名"]
      //补充：参数格式整理好
      let props = `${attr.attrId}:${attrValue}:${attr.attrName}`;
      this.searchParams.props.push(props);
      //再次发请求
      this.getData();
    },
......
</script>
```



**需要进行数组去重！（高频面试题）**

```vue
<script>
    //收集平台属性地方回调函数（自定义事件）
    attrInfo(attr, attrValue) {
      // ["属性ID:属性值:属性名"]
      //参数格式整理好
      let props = `${attr.attrId}:${attrValue}:${attr.attrName}`;
      // 数组去重，这里采用了if方法进行数组去重。
      // if语句中只有一行代码时，可省略大花括号.
        if(this.searchParams.props.indexOf(props)==-1){
        this.searchParams.props.push(props);
       ////当if执行后，可再次发请求
      this.getData();
      }
    },
</script>
```

**删除平台的售卖属性值的面包屑。**

```html
<template>
......
             <!-- 平台的售卖属性值的面包屑 补写参数index，即：@click="removeAttr(index)" -->
            <li    
              class="with-x" v-for="(attrValue, index) in searchParams.props" :key="index">
              {{ attrValue.split(":")[1] }}<i @click="removeAttr(index)">×</i>
            </li>
......
</template>
<script>
//删除平台的售卖属性值的面包屑。这里是删除数组里的某个数据，所以需要一个参数(索引值)
    removeAttr(index){
      //再次整理参数
      this.searchParams.props.splice(index,1);
      //再次发请求
      this.getData()
    }
</script>
```

## 28. 排序操作（上）

在接口文档中，

| order | string |  N   | 排序方式为：1: 综合,  2: 价格       asc: 升序,  desc: 降序                    示例: "1:desc" |
| :---: | :----: | :--: | :----------------------------------------------------------: |

**问题一：order属性的属性值最多有多少种写法？**

**答：**四种。1:asc、1.desc、2:asc、2:desc

**问题二：应先考虑：谁应该有类名？通过order属性值当中是包含1（综合）或者包含2（价格）**

```html
......
			  <ul class="sui-nav">
                <li :class="{active: searchParams.order.indexOf('1') != -1}">
                  <a>综合</a>
                </li>
                <li :class="{active: searchParams.order.indexOf('2') != -1}">
                  <a>价格</a>
                </li>
              </ul>
......
```

`<li :class="{active: searchParams.order.indexOf('1') != -1}">`写得比较复杂，可以放在computed里书写。

```html
<template>
......
               <ul class="sui-nav">
                <li :class="{ active: isOne}">
                  <a>综合</a>
                </li>
                <li :class="{ active: !isOne }">
                  <a>价格</a>
                </li>
              </ul>
......
</template>
<script>
    ......
computed:{
    isOne(){
                  return this.searchParams.order.indexOf("1") != -1;
    }
}
    ......
</script>
```

**问题三：谁应该有箭头？**

**①在阿里巴巴网页上搜索需要的内容**：https://www.iconfont.cn/search/index?searchType=icon&q=up&page=1&fromCollection=1&fills=&tag=

然后在public文件夹中的index.html中引用

```html
  <link rel="stylesheet" href="https://at.alicdn.com/t/font_3063860_l1hq82jazlm.css">
```

**②**然后在SearchSelector文件夹中：【iconfont一定要写】

```html
                <li :class="{ active: !isOne }">
                  <a>价格  <span v-show="!isOne" class="iconfont icon-sort-down"></span></a>
                </li>
```

**③**设置业务逻辑

```html
              <ul class="sui-nav">
                <li :class="{ active: isOne }">
                  <a>综合
                    <span v-if="isOne" class="iconfont" :class="{'icon-sort-up':isAsc,'icon-sort-down':isDesc}"></span>
                  </a>
                </li>
                <li :class="{ active: isTwo }">
                  <a>价格
                    <span v-show="isTwo" class="iconfont" :class="{'icon-sort-up':isAsc,'icon-sort-down':isDesc}"></span>
                  </a>
                </li>
              </ul>
```



## 29. 操作排序（下）

对升序降序的操作

```html
<template>
    ......
                    <li :class="{ active: isOne }"  @click="changeOrder('1')">
                  <a>综合
                    <span v-if="isOne" class="iconfont" :class="{'icon-sort-up':isAsc,'icon-sort-down':isDesc}"></span></a>
                </li>
                <li :class="{ active: isTwo }"  @click="changeOrder('2')">
                  <a>价格
                    <span v-show="isTwo" class="iconfont" :class="{'icon-sort-up':isAsc,'icon-sort-down':isDesc}"></span></a>
                </li>
    ......
</template>
<script>
   ......
	//排序操作
    changeOrder(flag){
      //flag形参：它是原始数据，是一个标记，代表用户点击的是 综合(1) 还是 价格(2)  【用户点击时，@click="changeOrder('1')"传参进来的】
      //这里获取起始状态
      let originOrder = this.searchParams.order;
      let originFlag = this.searchParams.order.split(":")[0];
      let originSort = this.searchParams.order.split(":")[1];
      console.log("起始flag为"+originFlag,"用户点击的flag"+flag);
       
      //准备一个新的order属性值
      let newOrder = ''
      if(flag == originFlag){
        //  三元表达式(expr1)?(expr2):(expr3)。expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3
        newOrder = `${originFlag}:${originSort == "desc"?"asc":"desc"}`
      }else{
        newOrder = `${flag}:${"desc"}`
      }
       
      //将新的order赋予个searchParams
      this.searchParams.order = newOrder;
       
      //再次重新发请求
      this.getData();
    }
    ......
</script>
```



# 复习四

**前端三个重要的原理：轮播图(Carousel)、分页器(Pagination)、日历**



# Day7

## 30. 分页器静态组件（分页器原理）

**前端三个重要的原理：轮播图(Carousel)、分页器(Pagination)、日历**

注册全局组件 分页器(Pagination)。

【本次项目需掌握自定义分页功能】

**问题一：分页器展示需要哪些数据（条件）？**

1.一共有多少页？用**pageNo**字段代表页数。

2.当前是第几页？

3.每一页有多少数据展示？用**pageSize**字段进行代表。

4.整个分页器一共有多少条数据？用**total**字段进行代表，（因此可额外获取另一条信息：一共多少页？）。

5.需要知道分页器连续页码的个数是多少？用**continues**进行代表，一般是**五页**或者**七页**【奇数】，因为奇数对称（好看）。



**总结：对于分页器而言，自定义的前提需要知道四个条件。**

**(1). pageNo：当前第几个**

**(2).pageSize：代表每一页展示多少条数据**

**(3).total：代表整个分页一共要展示多少条数据**【**可得到总共多少页totalpage**】

**(4).continues：代表分页连续页码的个数**【重要部分】



## 31. 分页器起始与结束数字计算（分页器逻辑）

**<strong style = "color:red">组件通信方法：</strong>**

​	**props：**（父给子）

​	**插槽：**（父给子）

​	**自定义事件：**（子给父）

​	**vuex：**（万能的方法，该方法可以用兄弟之间，但是本次项目用来当仓库数据）

​	**$bus：**（万能的方法，全局事件总线）

​	**pubsub-js：**（万能的方法，但是在vue中用得少）



### 31.1 分页器起始与结束（分页器显示的逻辑）

**一).这里使用的是父传子**：

**第一步：**在父组件Search模块中传数据。

```html
          <!-- 分页器 测试分页器阶段，这里数据将来需要替换的-->
          <Pagination :pageNo="1" :pageSize="3" :total="91" :continues="5"/>

```

**第二步：**在子组件Pagination的index.js中用props接收父传来的数据

```js
export default {
  name: "Pagination",
  props:['pageNo','pageSize','total','continues']
};
```



**二).分页器（分页器逻辑）**

自定义分页器，在开发时先用自己传递的假数据进行调试，调试成功后再用服务器数据。

**对于分页器而言，需要算出连续页面起始数字和结束数字。**

**分页器上面的数字的业务逻辑(用computed)：**

**pageNo**为当前页；

**continues**为连续的页数；

**totalPage**为总页数；

**start**为起始页数；

**end**为结束页数。

```html
<template>
......
    <h2>{{startNumAndEndNum}}------{{pageNo}}</h2>
......
</template>
<script>  
    ......
  computed:{
    //知道条数之后可以算出总共多少页
    totalPage(){
      //向上取整
      return Math.ceil(this.total/this.pageSize);
    },
    //计算出连续的页码起始数字与结束数字【连续页码的数字，至少有5页】
    startNumAndEndNum(){
      //进行解构：const {continues,pageNo,totalPage} = this;。解构的原因是：因为接下来是直接用的变量名，若不解构则就作为实际属性使用。
      const {continues,pageNo,totalPage} = this;
      //先定义两个变量存储起始数字与结束数字
      let start = 0,end = 0;
      //连续页码数字为5【至少为五页】，若出现不正常现象【不够五页】
      //【不正常现象】：【总页数没有连续页码多】
      if(continues > totalPage){
        start = 1;
        end = totalPage;
      }else{
        //【正常现象】:【连续页码5，但是总页数一定是大于5的】
        //起始数字
        start = pageNo - Math.floor(continues/2);
        //结束数字
        end = pageNo + Math.floor(continues/2);
        //【不正常现象】：【start数字出现0或者负数】，需纠正
        if(start < 1){
          start = 1;
          end = continues;
        }
        //【不正常现象】：【end数字超过总页码数】，需纠正
        if(end > totalPage){
          start = totalPage - continues+1;
          end = totalPage;
        }
      }
      return {start,end};
    }
      ......
</script>
```

### 31.2 分页器的动态展示（分页器按钮显示的逻辑）

分页器动态展示，可分为上中下

【中间部分】

**v-for可以遍历：数组|数字|字符串|对象**

分页器页码按钮显示逻辑：

```html
<template>
  <div class="pagination">
    <!-- 上 -->
    <button>上一页</button>
    <button v-if="startNumAndEndNum.start > 1">1</button>
    <button v-if="startNumAndEndNum.start > 2">···</button>

    <!-- 中 -->
    <button v-for="(page,index) in startNumAndEndNum.end" :key="index" v-show="page >= startNumAndEndNum.start">{{page}}</button>

    <!-- 下 -->
    <button v-if="startNumAndEndNum.end < totalPage-1">···</button>
    <button v-if="startNumAndEndNum.end <  totalPage">{{totalPage}}</button>
    <button>下一页</button>
<h2>{{startNumAndEndNum}}------{{pageNo}}</h2>
    <button style="margin-left: 30px">共 {{total}} 条</button>
  </div>
</template>
```



### 31.3 分页器的完成

将子组件Pagination中的业务传给父组件Search。

**子传父：**

**第一步：**在父组件Search中进行注册自定义事件`@getPageNo="getPageNo"`

```html
          <!-- 分页器 测试分页器阶段，这里数据将来需要替换的-->
          <Pagination :pageNo="searchParams.pageNo" :pageSize="searchParams.pageSize" :total="total" :continues="5" @getPageNo="getPageNo"/>
```

**第二步：**在父组件中Search中定义自定义事件`@getPageNo="getPageNo"`的回调事件

```html
<script>
......
methods:{
    //自定义事件的回调函数---获取当前第几页(子组件Pagination给父组件Search传)
    getPageNo(pageNo){
      //子组件pagination已经整理好了数据，可带给服务器参数
      this.searchParams.pageNo = pageNo;
      //再次发请求
      this.getData();
    }
}
......
</script>
```

**第三步：**在子组件Pagination中用`@click=“$emit('getPageNo',????)”`编写事件的触发

```html
<template>
  <div class="pagination">
    <!-- 上 -->
    <button :disabled="pageNo==1" @click="$emit('getPageNo',pageNo-1)">上一页</button>
    <button v-if="startNumAndEndNum.start > 1" @click="$emit('getPageNo',1)">1</button>
    <button v-if="startNumAndEndNum.start > 2">···</button>

    <!-- 中 -->
    <button v-for="(page,index) in startNumAndEndNum.end" :key="index" v-show="page >= startNumAndEndNum.start" @click="$emit('getPageNo',page)">{{page}}</button>

    <!-- 下 -->
    <button v-if="startNumAndEndNum.end < totalPage-1">···</button>
    <button v-if="startNumAndEndNum.end <  totalPage" @click="$emit('getPageNo',totalPage)">{{totalPage}}</button>
    <button :disabled="pageNo==totalPage" @click="$emit('getPageNo',pageNo+1)">下一页</button>
<h2>{{startNumAndEndNum}}------{{pageNo}}</h2>
    <button style="margin-left: 30px">共 {{total}} 条</button>
  </div>
</template>
```

**今日作业：手写分页器**



### 31.4 分页器添加类名

在子组件Pagination中写上动态绑定的类名，使其在被点击时，按钮呈现颜色

```html
<template>
    ......
  <div class="pagination">
    <!-- 上 -->
    <button :disabled="pageNo == 1" @click="$emit('getPageNo', pageNo - 1)">
      上一页
    </button>
    <button
      v-if="startNumAndEndNum.start > 1"
      @click="$emit('getPageNo', 1)"
      :class="{ active: pageNo == 1 }"
    >
      1
    </button>
    <button v-if="startNumAndEndNum.start > 2">···</button>

    <!-- 中 -->
    <button
      v-for="(page, index) in startNumAndEndNum.end"
      :key="index"
      v-show="page >= startNumAndEndNum.start"
      @click="$emit('getPageNo', page)"
      :class="{active:pageNo==page}"
    >
      {{ page }}
    </button>

    <!-- 下 -->
    <button v-if="startNumAndEndNum.end < totalPage - 1">···</button>
    <button
      v-if="startNumAndEndNum.end < totalPage"
      @click="$emit('getPageNo', totalPage)"
      :class="{active:pageNo==totalPage}"
    >
      {{ totalPage }}
    </button>
    <button
      :disabled="pageNo == totalPage"
      @click="$emit('getPageNo', pageNo + 1)"
    >
      下一页
    </button>
    <button style="margin-left: 30px">共 {{ total }} 条</button>
  </div>
    ......
</template>
............
<style>
    ......
    .active{
  background: skyblue;
}
</style>
```





## 32. 产品详情页面——滚动行为

**步骤：**

**1.**静态组件  (详情页的组件，暂未注册为路由组件)

当点击商品图片时，跳转到详情页面，在路由跳转的时候需要带上产品的ID给详情页面。用params传参，需占位

**2.**再搞请求

**3.**再再搞vuex

**4.**动态展示组件



**操作：**

先把Detail在路由文件中引用

```js
import Detail from '@/pages/Detail'
......
//配置路由
export default new VueRouter({
    //配置路由
    routes: [{
            // 这个的路由跳转需要带参数，所以需要占位，多写一下/:skuid
            path: "/detail/:skuid",
            component: Detail,
            meta: { show: true }
        }, 
             ......
    ]
```

**Search组件**中

```html
<div class="p-img">
                    <!-- 因为跳转的属性值中出现了变量，这是动态的跳转，所以是:to -->
                    <router-link :to="`/detail/${good.id}`">
                      <img :src="good.defaultImg"/>
                    </router-link>
</div>
```





**滚动行为**

查看vue官方文档Vue Router里的进阶滚动行为：

使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 `vue-router` 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。

**注意: 这个功能只在支持 `history.pushState` 的浏览器中可用。**

当创建一个 Router 实例，你可以提供一个 `scrollBehavior` 方法：

```js
const router = new VueRouter({
  routes: [...],
  scrollBehavior (to, from, savedPosition) {
    // return 期望滚动到哪个的位置
  }
})
```

举例：

```js
scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}
```



## 33. 产品详情页面数据获取

### 33.1 产品详情页面数据获取

**第一步：**在**api**文件中写**获取**产品详情**信息的接口**

```js
//获取detail模块数据   地址：/api/item/{ skuId }  请求方式是：get
export const reqGoodsInfo = (skuId) => requests({ url: `/item/${ skuId }`, method: "get" })
```

**第二步：**在**vuex**文件夹中**新增小仓库detail.js获取**产品**详情信息**

```js
const state = {}
const mutations = {};
const actions = {};
const getters = {};

export default {
    state,
    mutations,
    actions,
    getters
}
```

​		然后**将小仓库引入大仓库**中

```js
......
import detail from '@/store//detail';
......
export default new Vuex.Store({
    //实现Vuex仓库模块式开发存储数据
    modules: {
        ......
        detail
        ......
    }
})
```

**第三步：**发请求，捞数据，存到仓库。修改完善一下仓库`detail.js`：

```js
//引入api
import { reqGoodsInfo } from "@/api";
const state = {
    //这里data返回的是一个对象，所以应该写成空对象
    goodInfo: {}
}
const mutations = {
    GETGOODINFO(state, goodInfo) {
        state.goodInfo = goodInfo;
    }
};
const actions = {
    //获取产品信息的action
    async getGoodInfo({ commit }, skuId) {
        //当用户dispatch的时候派发得到的ID要带过去
        let result5 = await reqGoodsInfo(skuId);
        if (result5.code == "200") { //表示请求成功
            commit("GETGOODINFO", result5.data);
        }
    }
};
const getters = {};

export default {
    state,
    mutations,
    actions,
    getters
}
```

**第四步：**在detail组件中派发action，写在`mounted`中，记得要把产品的ID带上（ID在路由的params参数中）。

```js
    mounted(){
      //派发action获取产品详情的信息
      // console.log(this.$route.params)//{skuid: "7"}，其中skuid为占位符，可先console.log(this.$route.params)看看占位符的命名
      this.$store.dispatch('getGoodInfo',this.$route.params.skuid)
    }
```

### 33.2 产品详情页面动态展示数据

先在`detail的小仓库`中，用`getters`简化`detail.js`中的数据

```js
//简化数据而生
const getters = {
    categoryView(state) {
       //例：state.goodInfo初始状态下是空对象，空对象的categoryView属性值是undefined，所以应该提前多声明一个空对象。
       //当前计算出的categoryView属性值至少是一个空对象，加上一个{},这样假的报错不会有了。
       return state.goodInfo.categoryView || {};
    }
};
```

再在`detail.vue`中引入**{mapGetters}**，把`仓库`中的数据映射到`detail组件`上。

```html
<script>
  import { mapGetters } from "vuex";
  export default{
          computed: {
    ...mapGetters(['categoryView']),
 	},
  }
</script>
```

### 33.3 产品详情页面动态展示数据——右侧

方法同上一个小节35.2，上一节的跟进。

```js
......
const state = {
    //这里data返回的是一个对象，所以应该写成空对象
    goodInfo: {},
    skuInfo: {}
}
......
//简化数据而生
const getters = {
    categoryView(state) {
        //例：state.goodInfo初始状态下是空对象，空对象的categoryView属性值是undefined，所以应该提前多声明一个空对象。
        //当前计算出的categoryView属性值至少是一个空对象，加上一个{},这样假的报错不会有了。
        return state.goodInfo.categoryView || {};
    },
    skuInfo(state) {
        return state.goodInfo.skuInfo || {};
    }
};
......
```



在`Detail组件`中展示使用即可

```vue
......
	<!-- 导航路径区域 -->
      <div class="conPoin">
        <span v-show="categoryView.category1Name">{{categoryView.category1Name}}</span>
        <span v-show="categoryView.category2Name">{{categoryView.category2Name}}</span>
        <span v-show="categoryView.category3Name">{{categoryView.category3Name}}</span>
      </div>
......
        <!-- 右侧选择区域布局 -->
        <div class="InfoWrap">
          <div class="goodsDetail">
            <h3 class="InfoName">
              {{skuInfo.skuName}}
            </h3>
            <p class="news">
              {{skuInfo.skuDesc}}
            </p>
......
```



# 复习五

1.分页器的逻辑【要求掌握】

**对于分页器而言，自定义的前提需要知道四个条件。**

**(1). pageNo：当前第几个**

**(2).pageSize：代表每一页展示多少条数据**

**(3).total：代表整个分页一共要展示多少条数据**【**可得到总共多少页totalpage**】

**(4).continues：代表分页连续页码的个数**【重要部分】



2.产品详情页面的滚动行为。

3.产品详情页面的数据获取。





# Day8

## 34. Zoom放大镜展示数据—裁剪

父组件`Detail`传

```html
<template>
    ......
<!--放大镜效果-->
<Zoom :skuImageList="skuImageList" />
    ......
</template>
```

```html
<script>
import Zoom from "./Zoom/Zoom";
......
computed: {
    ...mapGetters(["categoryView", "skuInfo"]),
    skuImageList() {
    //给子组件的数据，若服务器的数据未回来，则skuInfo这个对象应赋值空对象
      return this.skuInfo.skuImageList || [];
    },
......
</script>
```

子组件`Zoom`接收

```html
<template>
  <div class="spec-preview">
    <img :src="imgObj.imgUrl" />
    <div class="event"></div>
    <div class="big">
      <img :src="imgObj.imgUrl" />
    </div>
    <div class="mask"></div>
  </div>
</template>

<script>
  export default {
    name: "Zoom",
    props:["skuImageList"],
    computed:{
      imgObj(){
        //以防从空对象中找数据未找到而返回undefined，从而自己先定义个空对象
        return this.skuImageList[0]||{}
      }
    }
  }
</script>
```

## 35. detail路由组件展示商品售卖属性

```html
<template>
		   <div class="choose">
            <div class="chooseArea">
              <div class="choosed"></div>
              <dl v-for="(spuSaleAttr,index) in spuSaleAttrList" :key="spuSaleAttr.id">
                <dt class="title">{{spuSaleAttr.saleAttrName}}</dt>
                <dd changepirce="0" v-for="(spuSaleAttrValue,index) in spuSaleAttr.spuSaleAttrValueList" :key="spuSaleAttrValue.id" :class="{active:spuSaleAttrValue.isChecked==1}" >{{spuSaleAttrValue.saleAttrValueName}}</dd>
              </dl>
            </div>
......
</template>
```

## 36. 产品售卖属性值——排他操作—裁剪

```html
<template>
......
    <dd
       changepirce="0"
       v-for="(spuSaleAttrValue, index) in spuSaleAttr.spuSaleAttrValueList"
       :key="spuSaleAttrValue.id"
       :class="{ active: spuSaleAttrValue.isChecked == 1 }"
       @click="changeActive(spuSaleAttrValue,spuSaleAttr.spuSaleAttrValueList)">
                  {{ spuSaleAttrValue.saleAttrValueName }}
    </dd>
......
</template>
<script>
......
//排他方法
  methods:{
    //产品的售卖属性值切换高亮
    changeActive(saleAttrValue,arr){
      //遍历全部的售卖属性值isChecked为零(无高亮)
      arr.forEach(item=>{
        item.isChecked = 0;
      });
      //点击的那个售卖属性值isChecked为壹(有高亮)
      saleAttrValue.isChecked = 1;
    }
  }
......
</script>
```



## 37. 放大镜操作（上）

### 37.1 放大镜操作——ImageList组件和Zoom组件之间的小操作

点击小图片，周围边框变颜色。在`ImageList.vue`中

```html
<template>
    ......
    <img :src="slide.imgUrl"
        :class="{active:currentIndex == index}"
        @click="changeCurrentIndex(index)" />
    ......
</template>
<script>
......
  data(){
    return{
        //设置响应式数据默认值为0
      currentIndex:0
    }
  },
 ......
  methods:{
    //点击小图片，小图片的周围会产生光亮边框
    changeCurrentIndex(index){
      //修改响应式数据
      this.currentIndex = index;
      //同时通知兄弟组件当前的索引值，改变大图
      this.$bus.$emit('getIndex',this.currentIndex);
    }
  }
......
</script>
```

传递全局事件，兄弟组件`Zoom.vue`接收

```html
<script>
......
    mounted(){
      //全局事件总线，获取兄弟组件传来的索引值
      this.$bus.$on('getIndex',(index)=>{
        console.log(index)
      })
    }
......
</script>
```

### 37.2 放大镜操作——大图片随着小图片的点击也进行改变

在`Zoom组件`中

![遮罩层](D:\前端\A学习笔记\Vue笔记\遮罩层.png)

```html
<script>
......
    data(){
      return{
        currentIndex:0
      }
    },
    computed:{
      imgObj(){
        //以防从空对象中找数据未找到而返回undefined，从而自己先定义个空对象
        //this.currentIndex是可变的；this.currentIndex = index;
        return this.skuImageList[this.currentIndex]||{}
      }
    },
    mounted(){
      //全局事件总线，获取兄弟组件传来的索引值
      this.$bus.$on('getIndex',(index)=>{
        //修改当前响应式数据，使大图也进行改变
        this.currentIndex = index;
      })
    }
......
</script>
```

### 37.3 放大镜操作——遮罩层

![](D:\前端\A学习笔记\Vue笔记\遮罩层.png)

**设置遮罩层随着鼠标的移动一起移动**

```html
<template>
......
        <div class="event" @mousemove="handler"></div>
    	<!-- 遮罩层 -->
       <div class="mask" ref="mask"></div>
......
</template>
<script>
    ......
	methods:{
      handler(event){
        let mask = this.$refs.mask;
        let left = event.offsetX - mask.offsetWidth/2;
        let top = event.offsetY - mask.offsetHeight/2;
        //约束范围
        //左右的约束范围
        if(left <= 0 ){left = 0;}
        if(left >= mask.offsetWidth){left = mask.offsetWidth;}
        
        //上下的约束范围
        if(top <=0 ){top =0;}
        if(top >= mask.offsetHeight){top = mask.offsetHeight;}

        //修改元素的left|top属性值
        mask.style.left = left + 'px';
        mask.style.top = top + 'px';
      }
    }
    ......
</script>
```

**设置右侧的大图移动情况（补充）**

```html
<template>
......
        <!-- 右侧大图 -->
    <div class="big">
      <img :src="imgObj.imgUrl" ref="big"/>
    </div>
        <!-- 遮罩层 -->
    <div class="mask" ref="mask"></div>
......
</template>
<script>
......
    methods:{
      handler(event){
        let mask = this.$refs.mask;
        let left = event.offsetX - mask.offsetWidth/2;
        let top = event.offsetY - mask.offsetHeight/2;
        if(left <= 0 ){left = 0;}
        if(left >= mask.offsetWidth){left = mask.offsetWidth;}
        if(top <=0 ){top =0;}
        if(top >= mask.offsetHeight){top = mask.offsetHeight;}
        mask.style.left = left + 'px';
        mask.style.top = top + 'px';
          
        //设置右侧大图的情况
        let big = this.$refs.big;
        big.style.left = -2 * left +'px';
        big.style.top = -2 * top +'px';
      }
    }
......
</script>
```



## 38. 购买产品个数的操作

```html
<template>
......
		<div class="controls">
            <input autocomplete="off" class="itxt" v-model="skuNum" @change="changeSkuNum"/>
               <a href="javascript:" class="plus" @click="skuNum++">+</a>
               <a href="javascript:" class="mins" @click="skuNum > 1 ? skuNum--:skuNum=1">-</a>
        </div>
......
</template>

<script>
......
  data(){
    return{
      //产品的个数
      skuNum:1
    }
  },
  methods:{
            //表单元素修改产品个数
    changeSkuNum(event){
      //用户输入的文本 * 1
      let value = event.target.value * 1;
      //如果用户输入的文本非法【字符串、负数】
      if(isNaN(value)|| value < -1){
        console.log("非法")
        this.skuNum = 1;
      }else{
        //向上取整【带有小数的情况】
        this.skuNum = Math.ceil(value);
      }
    }
  }
......
</script>
```

## 39. 加入购物车（这个路由和其他的路由不太一样）

“加入购物车”的按钮，需要用到的操作步骤：

1.发送请求，将产品的数据信息存储于服务器。

2.进行路由的跳转，跳转到购物车界面。

3.

### 39.1 ”加入购物车“按钮的步骤

一、写好`api`接口

```js
//获取更新某一个产品的个数
///api/cart/addToCart/{ skuId }/{ skuNum }
export const reqAddOrUpdateShopCart = (skuId, skuNum) => requests({ url: `/cart/addToCart/${skuId}/${skuNum}`, method: "post" })
```

二、完善仓库`detail`数据

```js
import { reqGoodsInfo, reqAddOrUpdateShopCart } from "@/api";
const actions = {
        async AddOrUpdateShopCart({ commit }, { skuId, skuNum }) {
        //加入购物车返回的解构数据skuId、skuNum。
        //加入购物车后（发请求后），前台将参数带给服务器，服务器写入数据成功，并未返回其他的数据，只返回了code=200，代表这次操作成功。
        //因服务器未返回其余数据，所以不需要三连环存储数据。
        let result = await reqAddOrUpdateShopCart(skuId, skuNum);

    }
}
```

三、在`Detail`组件中

```html
<template>
......
		<div class="add">
                <!-- 以往的路由跳转：从A跳到B。本次的路由跳转之前，发请求将购买的产品信息通过请求的形式通知服务器，服务器进行相应的存储 -->
			<a @click="addShopcar">加入购物车</a>
		</div>
......
</template>
<script>
......
  methods:{
    addShopcar(){
      //1.发请求---将产品信息加入到数据库中（通知服务器）
      // this.$store.dispatch('addOrUpdateShopCart',{skuId:this.$route.params.skuid,skuNum:this.skuNum})调用的是仓库中的addOrUpdateShopCart函数，addOrUpdateShopCart函数加上了async语法题，所以返回得到的一定是promise。
      this.$store.dispatch('addOrUpdateShopCart',{skuId:this.$route.params.skuid,skuNum:this.skuNum})
      //2.若服务器存储成功---进行路由跳转传递参数
      //3.若失败，则给用户提示
    }
  }
......
</script>
```

四、修改仓库`detail`中的内容，加入返回成功和失败的情况内容。

```js
    //将产品添加到购物车中
    async addOrUpdateShopCart({ commit }, { skuId, skuNum }) {
        //加入购物车返回的解构数据skuId、skuNum。
        //加入购物车后（发请求后），前台将参数带给服务器，服务器写入数据成功，并未返回其他的数据，只返回了code=200，代表这次操作成功
        //因服务器未返回其余数据，所以不需要三连环存储数据。
        //注：async函数执行返回的结果一定是一个promise【要么成功，要么失败】

        let result6 = await reqAddOrUpdateShopCart(skuId, skuNum);
        //当前这个函数执行返回Promise
        //当code返回200时为成功
        if (result6.code == 200) {
            return "ok"
        } else {
            //返回失败时
            return Promise.reject(new Error('faile'));
        }
        // console.log(result6);
    }
```

五、在四完成之后可以进行路由跳转，则再次改写`Detail组件`中的内容，用上了try{}catch{}语法。

```js
......
    async addShopcar(){
      //1.发请求---将产品信息加入到数据库中（通知服务器）
      // this.$store.dispatch('addOrUpdateShopCart',{skuId:this.$route.params.skuid,skuNum:this.skuNum})调用的是仓库中的addOrUpdateShopCart函数，返回得到的是promise。
      try{
        await this.$store.dispatch('addOrUpdateShopCart',{
          skuId:this.$route.params.skuid,
          skuNum:this.skuNum
        });
        //路由跳转
      }catch(error){
        alert(error.message)
      }
......
```

六、在路由`router`文件夹中引入`AddCartSuccess组件`的路由

```js
import AddCartSuccess from '@/pages/AddCartSuccess'
export default [
......
	{
        path: "/addcartsuccess",
        component: AddCartSuccess,
        //meta是显示底下的floor组件的
        meta: { show: true }
    },
    ......
]
```

### 39.2  路由传递参数结合会话存储(成功路由跳转与参数传递)

`addCartSuccess查看详情`

**HTML5新增的功能：本地存储和会话存储。**

**本地存储和会话存储不可以存对象。**

所以这里用`    sessionStorage.setItem("SKUINFO",JSON.stringify(this.skuInfo));`先把对象设置转为字符串，存到本地存储中。

再在所需的组件`AddCartSuccess组件`里写computed

```html
<script>
......
    computed:{
      skuInfo(){
        return JSON.parse(sessionStorage.getItem('SKUINFO'))
      }
......
</script>
```

在`Detail组件`跳转的地方补写一下跳转路径的代码

```html
<script>
	async addShopcar(){
      //1:发请求---将产品信息加入到数据库中（通知服务器）
      // this.$store.dispatch('addOrUpdateShopCart',{skuId:this.$route.params.skuid,skuNum:this.skuNum})调用的是仓库中的addOrUpdateShopCart函数，返回得到的是promise。
      //2:需要知道请求是成功还是失败，若成功则路由跳转，若失败则给用户提示
      try{
        //成功
        await this.$store.dispatch('addOrUpdateShopCart',{
          skuId:this.$route.params.skuid,
          skuNum:this.skuNum
        });
        //3：进行路由跳转
        //4：在路由跳转时将产品信息带给下一级路由组件。
        //一些简单的数据skuNum，通过query形式给路由组件传递；而产品信息的数据【比较复杂：skuInfo】，通过会话存储（不持久化，会话结束数据再消失）
        // 跳转传参方法一：用query直接存储，但是网址会显得比较乱。  this.$router.push({name:"addcartsuccess",query:{skuInfo:this.skuInfo,skuNum:this.skuNum}})
        // 跳转传参方法二：用本地存储(以下便是)：
        sessionStorage.setItem("SKUINFO",JSON.stringify(this.skuInfo));
        this.$router.push({name:"addcartsuccess",query:{skuInfo:this.skuInfo,skuNum:this.skuNum}})
      }catch(error){
        //失败
        alert(error.message)
      }
      //2.若服务器存储成功---进行路由跳转传递参数
      //3.若失败，则给用户提示
    }
</script>
```

### 39.3 购物车静态组件与修改

`查看购物车ShopCart`

添加路由

```js
import ShopCart from '@/pages/ShopCart'
export default [{
        path: "/shopcart",
        component: ShopCart,
        //meta是显示底下的floor组件的
        meta: { show: true }
    },
]
```

在`AddCartSuccess组件中`添加路由跳转

```js
<router-link to="/shopcart">去购物车结算</router-link>
```

### 39.4 UUID游客身份获取购物车数据

静态组件写完了，就发请求，获取购物车数据，操作vuex三连环、组件获取数据展示数据

在api引入shopcart的接口——>新建shopcart数据小仓库，引到大仓库中——>

用uuid

**一、**补写数据仓库`detail`

```js
import { reqCartList } from "@/api";
const state = {};
const mutations = {};
const actions = {
    //获取购物车列表数据
    async getCartList({ commit }) {
        let result7 = await reqCartList();
        //测试是否能获取个人购物车数据
        console.log(result7);
    }
};
const getters = {};

export default {
    state,
    mutations,
    actions,
    getters
}
```

**二、**捞购物车的数据。在ShopCart组件中补：

```js
......
	mounted(){
      this.getData();
    },
    methods:{
      //获取个人购物车数据
      getData(){
        this.$store.dispatch('getCartList')
      }
    }
......
```

**三、**现在仓库detail中写

```js
//封装游客身份模块UUID——>生成一个随机字符串（生成之后不能再变化）
import { getUUID } from '@/utils/uuid_token'
const state = {
    //游客临时身份
    uuid_token: getUUID()
}
```

**四、**在`uuid_token.js文件`中用uuid随机生成

```js
import { v4 as uuidv4 } from 'uuid';
//生成一个随机字符串，且每次执行不能发生变化，游客的身份持久保持
export const getUUID = () => {
    //先从本地存储获取uuid（看看本地存储中是否有）
    let uuid_token = localStorage.getItem('UUIDTOKEN');
    //如果没有
    if (!uuid_token) {
        //调用UUID的函数uuidv4()生成游客临时身份
        uuid_token = uuidv4();
        //生成之后本地存储一次
        localStorage.setItem('UUIDTOKEN', uuid_token)
    }
    //切记务必要有返回值，没有返回值则是undefined
    return uuid_token;
}
```

**五、**在api的`request.js`中引入仓库store、并使用请求头【Request Headers】添加uuid_token

```js
//在当前模块中引入store
import store from '@/store';

//请求拦截器：可以在发请求之前，可处理一些业务。
requests.interceptors.request.use((config) => {
    //config:配置对象，对象中有一个属性很重要(即：headers请求头)
    if (store.state.detail.uuid_token) {
        //请求头添加一个字段(userTempId)，命名是与后台商量好的
        config.headers.userTempId = store.state.detail.uuid_token;
    }
    nprogress.start() //③.进度条开始动
    return config;
})
```





### 39.5 购物车动态展示数据

购物车的动态数据格式有些不完美

在补写`仓库shopcart`，简化其数据

```js
import { reqCartList } from "@/api";
const state = {
    cartList: []
};
const mutations = {
    GETCARTLIST(state, cartList) {
        state.cartList = cartList;
    }
};
const actions = {
    //获取购物车列表数据
    async getCartList({ commit }) {
        let result7 = await reqCartList();
        //测试是否能获取个人购物车数据
        console.log(result7);
        if (result7.code == 200) {
            commit("GETCARTLIST", result7.data)
        }
    }
};
const getters = {
    cartList(state) {
        return state.cartList[0] || {}
    }
};

export default {
    state,
    mutations,
    actions,
    getters
}
```

修改`ShopCart组件`中

```html
<template>
......
            <ul class="cart-list" v-for="(cart,index) in cartInfoList" :key="cart.id">
          <li class="cart-list-con1">
            <input type="checkbox" name="chk_list" :checked="cart.isChecked==1">
          </li>
          <li class="cart-list-con2">
            <img :src="cart.imgUrl">
            <div class="item-msg">{{cart.skuName}}</div>
          </li>
          <li class="cart-list-con4">
            <span class="price">{{cart.skuPrice}}.00</span>
          </li>
          <li class="cart-list-con5">
            <a href="javascript:void(0)" class="mins">-</a>
            <input autocomplete="off" type="text" :value="cart.skuNum" minnum="1" class="itxt">
            <a href="javascript:void(0)" class="plus">+</a>
          </li>
          <li class="cart-list-con6">
            <span class="sum">{{cart.skuNum * cart.skuPrice}}</span>
          </li>
          <li class="cart-list-con7">
            <a href="#none" class="sindelet">删除</a>
            <br>
            <a href="#none">移到收藏</a>
          </li>
        </ul>
......
            <input class="chooseAll" type="checkbox" :checked="isAllCheck">
......
              <i class="summoney">{{totalPrice}}</i>

</template>
<script>
    import { mapGetters } from 'vuex';
......
	computed:{
      ...mapGetters(['cartList']),
      //购物车数据
      cartInfoList(){
        return this.cartList.cartInfoList||[];
      },
      //计算购买产品的总价
      totalPrice(){
        let sum = 0;
        this.cartInfoList.forEach(item=>{
          sum+=item.skuNum * item.skuPrice;
        });
        return sum
      },
      //判断底部复选框是否需要勾选【全部产品都勾选则勾选】
      isAllCheck(){
        //every的使用方法要记得【遍历数组里原理，只要全部元素的isChecked属性都为1，则为真，true】
          return this.cartInfoList.every(item=>item.isChecked==1)
      }
    }
......
</script>
```

### 39.6 处理产品数量、修改购物车产品的数量完成

处理按钮

```html
<template>
......
          <li class="cart-list-con5">
            <a href="javascript:void(0)" class="mins" @click="handler('minus',-1,cart)">-</a>
            <input autocomplete="off" type="text" :value="cart.skuNum" minnum="1" class="itxt" @change="handler('change',$event.target.value * 1,cart)">
            <a href="javascript:void(0)" class="plus" @click="handler('add',1,cart)">+</a>
          </li>
......
</template>
<script>
......
    methods:{
      //获取个人购物车数据
      getData(){
        this.$store.dispatch('getCartList')
      },
      async handler(type,disNum,cart){
        //type：为了区分这三个元素
        //disNum形参，是变化量： +号为变化量(1)，-号为变化量(-1)，input是最终的个数(不是变化量)
        //cart：表示是哪个产品，是身上的id
        console.log("触发了handler",type,disNum,cart)
        switch(type){
          case "add":
            disNum = 1;
            break;
          case "minus":
            //判断产品的个数大于1，才可以传递给服务器-1;若个数小于等于1，则传递给服务器个数0
            disNum = cart.skuNum > 1 ? -1 : 0;
            break;
          case "change":
            //用户输入的是最终量，若为非法的（带有汉字等），则带给服务器的变化量应该为0
            if(isNaN(disNum)||disNum < 1){
              disNum = 0;
            }else{
              //正常情况下，但用户输入的值有小数，则带给服务器的变化量应该为：用户输入进来的 - 产品的起始个数
              disNum = parseInt(disNum) - cart.skuNum;
            }
            //简写形式(这里不建议这样写，不好阅读)： disNum = (isNaN(disNum)||disNum < 1 )? 0 : (parseInt(disNum) - cart.skuNum);
          break;
        }
        //派发action
        try{
          //代表修改成功
          await this.$store.dispatch("addOrUpdateShopCart",{skuId:cart.skuId,skuNum:disNum});
          //再一次获取服务器最新数据进行展示
          this.getData();
        }catch(error){
	        }
      }
    },
......
</script>
```



### 39.7 修改产品个数【对函数进行节流】

这里可以用**节流**的方式，防止发生卡顿现象。

```html
<script>
//第一步：
//引入方式：把lodash中的文件，按需引入功能throttle函数
//这里的throttle.js文件是默认暴露的，所以不需要加花括号
import throttle from "lodash/throttle";
......
methods:{
    ......
      //第二步：
      //修改某一个产品的个数[节流]
    handler: throttle(async function (type, disNum, cart) {
      //type：为了区分这三个元素
      //disNum形参，是变化量： +号为变化量(1)，-号为变化量(-1)，input是最终的个数(不是变化量)
      //cart：表示是哪个产品，是身上的id
      // console.log("触发了handler",type,disNum,cart)
      switch (type) {
        case "add":
          disNum = 1;
          break;
        case "minus":
          //判断产品的个数大于1，才可以传递给服务器-1;若个数小于等于1，则传递给服务器个数0
          disNum = cart.skuNum > 1 ? -1 : 0;
          break;
        case "change":
          //用户输入的是最终量，若为非法的（带有汉字等），则带给服务器的变化量应该为0
          if (isNaN(disNum) || disNum < 1) {
            disNum = 0;
          } else {
            //正常情况下，但用户输入的值有小数，则带给服务器的变化量应该为：用户输入进来的 - 产品的起始个数
            disNum = parseInt(disNum) - cart.skuNum;
          }
          //简写形式(这里不建议这样写，不好阅读)： disNum = (isNaN(disNum)||disNum <script 1 )? 0 : (parseInt(disNum) - cart.skuNum);
          break;
      }
      //派发action
      try {
        //代表修改成功
        await this.$store.dispatch("addOrUpdateShopCart", {
          skuId: cart.skuId,
          skuNum: disNum,
        });
        //再一次获取服务器最新数据进行展示
        this.getData();
      } catch (error) {}
    }, 800),
     ......
}
</script>
```



### 39.8 删除购物车产品的操作

写接口——>写仓库——>写组件

在`api的index.js中`写接口

```js
//获取删除购物车产品的接口
// URL:/api/cart/deleteCart/{skuId}  method:delete
export const reqDeleteCartById = (skuId) => requests({ url: `/cart/deleteCart/${skuId}`, method: 'delete' });
```

在`store仓库中`写仓库

```js
const actions = {
    ......
	//删除购物车某一个产品（没有返回的信息，所以三连环不需要写完整）
    async deleteCartListBySkuId({ commit }, skuId) {
        let result8 = await reqDeleteCartById(skuId);
        if (result8.code == 200) {
            return "ok";
        } else {
            return Promise.reject(new Error("faile"));
        }
    }
    ......
}
```

在`ShopCart组件中`写组件

```html
<template>
......
           <li class="cart-list-con7">
            <a href="#none" class="sindelet" @click="deleteCartListById(cart)">删除</a>
            <br>
            <a href="#none">移到收藏</a>
          </li>
......
</template>
<script>
......
	methods:{
      async deleteCartListById(cart){
        try{
          //若删除成功则再发请求获取新的数据进行展示
          await this.$store.dispatch('deleteCartListBySkuId',cart.skuId);
          this.getData();
        }catch(error){
          alert(error.message);
        }
      }
    }
......
</script>
```



### 39.9 修改产品状态

写接口——>写仓库——>写组件

在`api的index.js中`写接口

```js
//修改商品的选中状态
//URL: /api/cart/checkCart/{skuID}/{isChecked}
export const reqUpdateCheckedByid = (skuId, isChecked) => requests({ url: `/cart/checkCart/${skuID}/${isChecked}`, method: 'get' })
```

在`store仓库中`写仓库

```js
    //修改购物车某一个产品选中状态
    async updateCheckedById({ commit }, { skuId, isChecked }) {
        let result9 = await reqUpdateCheckedByid(skuId, isChecked)
        if (result9.code == 200) {
            return 'ok';
        } else {
            return Promise.reject(new Error('faile'))
        }
    }
```

在`ShopCart组件中`写组件

```html
<template>
......
              <li class="cart-list-con1">
            <input
              type="checkbox"
              name="chk_list"
              :checked="cart.isChecked == 1"
              @change = "updateChecked(cart,$event)"
            />
          </li>
......
</template>
<script>
......
methods:{
    async updateChecked(cart, event) {
      //派发actions
      //带给服务器的参数isChecked，不是布尔值，应该是0|1
      try {
        //若修改数据成功，则再次获取服务器数据（购物车）
        let isChecked = event.target.checked ? "1" : "0";
        await this.$store.dispatch("updateCheckedById", {
          skuId: cart.skuId,
          isChecked,
        });
        this.getData();
      } catch (error) {
        //获取失败
        alert(error.message);
      }
    },
}
......
</script>
```



# 复习六

**面试高频题：防抖、节流、存储**

一、加入购物车

UUID：点击加入购物车时，通过请求头给服务器带临时身份给服务器，存储某一个用户购物车数据。

会话存储、去存储产品的信息一级展示功能。

二、购物车功能

修改产品的数量、删除某一个产品的接口、某一个产品的勾选状态切换。

# Day9

## 40. 删除全部选中的商品

context其实是个小仓库。

**context的小仓库其中：**

**commit**【提交mutations修改state】、

**getters**【计算属性】、

**dispatch**【派发action】、

**state**【当前仓库数据】



**注：可通过ID删除产品的接口【一次删一个】**

**Promise.all([p1,p2,p3])**

其中P1|P2|P3，每一个都是Promise对象。

若有一个Promise失败，则都失败，若都成功，则返回成功。

```js
    //删除全部勾选的产品
    deleteAllCheckedCart({ dispatch, getters }) {
        //context：小仓库，commit【提交mutations修改state】、getters【计算属性】、dispatch【派发action】、state【当前仓库数据】
        // console.log(getters.cartList.cartInfoList)
        //获取购物车中全部的产品（是一个数组）
        let PromiseAll = [];
        getters.cartList.cartInfoList.forEach(item => {
            let promise = item.isChecked == 1 ? dispatch('deleteCartListBySkuId', item.skuId) : '';
            //将每一次返回的Promise添加到数组中
            PromiseAll.push(promise);
        });
        //PromiseAll只要全部的p1|p2......都成功，则返回结果即为成功
        //若有一个失败，则返回即为失败结果。
        //返回的结果传回给ShopCart组件
        return Promise.all(PromiseAll)
    }
```

传回给`ShopCart组件`

```js
   //删除全部选中的产品
    async deleteAllCheckedCart(){
      try{
      //派发一个action
      await this.$store.dispatch("deleteAllCheckedCart");
      //再发请求获取购物车列表
      this.getData();
      }catch(error){
        alert(error.message);
      }
    }
```

## 41. "全部"产品的勾选状态修改

在`shopcart仓库中`

```js
    //修改全部产品的状态
    updateAllCartIsChecked({ dispatch, state }, isChecked) {
        //数组
        let promiseAll = [];
        state.cartList[0].cartInfoList.forEach((item) => {
            let promise = dispatch('updateCheckedById', { skuId: item.skuId, isChecked });
            promiseAll.push(promise);
        });
        //最终返回结果
        return Promise.all(promiseAll);
    }
```

在`ShopCart组件中`

```html
<template>
......
       <div class="select-all">
        <input class="chooseAll" type="checkbox" :checked="isAllCheck&&cartInfoList.length > 0" @change="updateAllCartChecked"/>
        <span>全选</span>
      </div>
......
</template>
<script>
......
    //修改全部产品的选中状态
    async updateAllCartChecked(event){
        try{
            let isChecked = event.target.checked ? "1" : "0";
            //派发action
            await this.$store.dispatch("updateAllCartIsChecked",isChecked);
            this.getData();
        }catch(error){
            alert(error.message);
        }
      }
......
</script>
```

## 42. 登录注册静态组件【重要（必会技能）】

**也可在css中配置别名@提示**

【background-image: url(~@/assets/images/icons.png);】

### 42.1 注册的静态组件

在`API文件中`写个接口

```js
export const reqGetCode = (phone) => requests({ url: `/api/user/passport/sendCode/${phone}`, method: "get" })

```

新建仓库`user`

```js
import { reqGetCode, reqUserRegister } from "@/api"
//登录与注册的仓库
const state = {
    code: ""
}
const mutations = {
    GETCODE(state, code) {
        state.code = code;
    }
}
const actions = {
    //获取验证码
    async getCode({ commit }, phone) {
        let result9 = await reqGetCode(phone)
        if (result9.code == 200) {
            commit('GETCODE', result9.data);
            return 'ok'
        } else {
            return Promise.reject(new Error('faile'))
        }
    },
    //用户注册
    async userRegister({ commit }, user) {
        let result10 = await reqUserRegister(user);
        // console.log(result10)
        if (result10.code == 200) {
            return 'ok'
        } else {
            return Promise.reject(new Error('fail'))
        }
    }
}
const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```

在`Register组件中`写入

```html
<template>
......
            <input type="text" placeholder="请输入你的手机号" v-model="phone">
......
            <input type="text" placeholder="请输入验证码" v-model="code">
......
            <input type="password" placeholder="请输入你的登录密码" v-model="password">
.......
            <input type="password" placeholder="请输入确认密码" v-model="password1">
......
            <input name="m1" type="checkbox" :checked="agree">
......
            <button @click="userRegister">完成注册</button>
......
</template>
<script>
......
    },
    methods:{
      //获取验证码
      async getCode(){
        //简单判断
        try{
          //若获取到验证码
          const {phone} =this;
          phone && (await this.$store.dispatch('getCode',phone));
          //将组件的code属性值变为仓库中的验证码
          // console.log(this.$store)
          this.code = this.$store.state.user.code
        }catch(error){}
      },
      //用户注册
      async userRegister(){
        try{
          const {phone,code,password,password1} = this;
          (phone&&code&&password==password1) && await this.$store.dispatch('userRegister',{phone,code,password});
          this.$router.push('./login')
        }catch(error){
          alert('fail')
        }
      }
    }
......
</script>
```



### 42.2 登录的静态组件

**token（令牌）：是用户唯一标识，是服务器下发的。**

**vuex仓库存储数据不是持久化的**

写`api文件`

```js
//登录
// URL：/api/user/passport/login   methods：post
export const reqUserLogin = (data) => requests({ url: `/user/passport/login`, data, method: "post" })
```

写仓库`user`

```js
import { reqUserLogin } from "@/api"
const state = {
    token: ""
    ......
}
const mutations = {
    USERLOGIN(state,token) {
        state.token = token
    }
    ......
}
const actions = {
    //登录页面【token】
    async userLogin({ commit }, data) {
        let result11 = await reqUserLogin(data);
        if (result11.code == 200) {
            commit("USERLOGIN", result11.data.token);
            return 'ok'
        } else {
            return Promise.reject(new Error('faile'));
        }
    }
  }
......
}
const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```

写组件`Login`

```html
<template>
......
                    <input type="text" placeholder="邮箱/用户名/手机号" v-model="phone">
......
                    <input type="text" placeholder="请输入密码" v-model="password">
......
    <form>
        <button class="btn" @click.prevent="userLogin">
                登&nbsp;&nbsp;录
        </button>
    </form>
</template>
<script>
......
  data() {
    return {
      phone: "",
      password: "",
    };
  .......
  methods: {
    //登录的回调函数
    async userLogin() {
      try {
        // const phone = this phone;
        // const password = this password;
        // 简写形式：
        const { phone, password } = this;
        phone && password && (await this.$store.dispatch("userLogin", { phone, password }));
        //跳转到home首页
        this.$router.push("/home")
      } catch (error) {
        alert(error.message);
      }
    },
......
</script>
```

### 42.3 携带token获取用户信息

写`API文件`

```js
//获取用户信息【需要带token向服务器要用户信息】
//URL: /api/user/passport/auth/getUserInfo   methods:get
export const reqUserInfo = () => requests({ url: `/user/passport/auth/getUserInfo`, method: "get" })
```

写`user仓库`

```js
import { reqUserInfo } from "@/api"

const mutations = {
......
    GETUSERINFO(state, userInfo) {
        state.userInfo = userInfo
    }
}
const actions = {
......
 //token获取用户信息（需要存储用户的信息，所以需要三连环）
    async getUserInfo({commit}) {
        let result12 = await reqUserInfo();
        if (result12.code == 200) {
            //提交用户信息
            commit("GETUSERINFO", result12.data);
            return 'ok'
        } 
    }
}
const getters = {}

export default {
    state,
    mutations,
    actions,
    getters
}
```



需要在`api文件中的request.js`请求头中补入信息

```js
//请求拦截器：可以在发请求之前，可处理一些业务。
requests.interceptors.request.use((config) => {
  ......
    //config:配置对象，对象中有一个属性很重要(即：headers请求头)
    //携带token给服务器
    if (store.state.user.token) {
        config.headers.token = store.state.user.token
    }
  ......
})
```

补写`Home组件`

```html
<script>
......
mounted() {
    //派发action：通过Vuex发起ajax请求，将数据存储在仓库中
    this.$store.dispatch("getFloorList");
    //获取用户信息展示
    this.$store.dispatch('getUserInfo');
  },
......
</script>
```

对`Header组件`的展示部分进行修改

这里用是否带有用户名来判断是否展示。

```html
<template>
......
        <!-- 没有用户名，则未登录 -->
          <p v-if="!userName">
            <span>请</span>
            <router-link to="./login">登录</router-link>
            <!-- <a href="###">登录</a> -->
            <router-link to="./register" class="register">免费注册</router-link>
          </p>
             <!-- 登录后 -->
          <p v-else>
            <a href="">{{userName}}</a>
            <a class="register">退出登录</a>
          </p>
......
</template>
<script>
......
  computed:{
    //用户名登录信息
    userName(){
      return this.$store。state.user.userInfo.name;
    }
  }
......
</script>
```

**注：vuex仓库存储数据不是持久化的，所以这里的程序写完后，登录之后再刷新，用户信息丢失。**

### 42.4 上一节登录业务存在的问题讲解（不完美的解决办法）

vuex仓库存储数据不是持久化的，所以这里的程序写完后，登录之后再刷新，用户信息丢失。

**将token转存到本地存储locationstorage中进行持久化存储。**

**写法一：**

**补写`仓库user`**

```js
......
const actions = {
 ......
    //登录页面【token】
    async userLogin({ commit }, data) {
        let result11 = await reqUserLogin(data);
        if (result11.code == 200) {
            commit("USERLOGIN", result11.data.token);
            //持久化存储token
            //写法一：持久化存储token
            localStorage.setItem("TOKEN", result11.data.token)
            return 'ok'
        } else {
            return Promise.reject(new Error("faile"));
        }
    }
 ......
    }
......
```

**写法二：**

**进行封装，在`utils文件夹下`新建`token.js`，**

```js
//存储token
export const setToken = (token) => {
    localStorage.setItem('TOKEN', token)
}
```

再在`仓库user`中引用即可

```js
import { setToken } from "@/utils/token";
......
const actions = {
    ......
    //登录页面【token】
    async userLogin({ commit }, data) {
        let result11 = await reqUserLogin(data);
        if (result11.code == 200) {
            commit("USERLOGIN", result11.data.token);
            //持久化存储token
            //写法二：持久化存储token
            setToken(result11.data.token);
            return 'ok'
        } else {
            return Promise.reject(new Error("faile"));
        }
    }
    ......
}
......
```



接着进行改写

将`仓库user`改写token的内容

**写法一：**

**补写`仓库user`**

```js
......
const state = {
    token: localStorage.getItem('TOKEN'),
}
......
......
const actions = {
    ......
    //登录页面【token】
    async userLogin({ commit }, data) {
        let result11 = await reqUserLogin(data);
        if (result11.code == 200) {
            commit("USERLOGIN", result11.data.token);
            //持久化存储token
            setToken(result11.data.token);
            return 'ok'
        } else {
            return Promise.reject(new Error("faile"));
        }
    }
    ......
}
......
```

**写法二：**

**进行封装，在`utils文件夹下`新建`token.js`**

```js
//存储token
export const setToken = (token) => {
    localStorage.setItem('TOKEN', token)
};
//获取token
export const getToken = () => {
    return localStorage.getItem("TOKEN");
}
```

再在`仓库user`中引用即可

```js
import { setToken, getToken } from "@/utils/token";
......
const state = {
    token: getToken(),
}
......
......
const actions = {
    ......
    //登录页面【token】
    async userLogin({ commit }, data) {
        let result11 = await reqUserLogin(data);
        if (result11.code == 200) {
            commit("USERLOGIN", result11.data.token);
            //持久化存储token
            setToken(result11.data.token);
            return 'ok'
        } else {
            return Promise.reject(new Error('faile'));
        }
    },
    ......
}
......
```

### 42.5 退出登录

在`Header组件中`写退出登录的方法

```html
<template>
......
		<a class="register" @click="logout">退出登录</a>
......
</template>
<script>
......
methods:{
        logout(){
      //退出登录需要：1.发请求【通知服务器退出登录清除数据(例如token)】；2.清除项目中的数据【userInfo、token】
      alert(123)
    }
}
......
</script>
```

写`api`

```js
//退出登录
//URL:/api/user/passport/logout   methods:get
export const reqLogout = () => requests({ url: `/user/passport/logout`, method: "get" })
```

写`仓库user`

```js
import { reqLogout } from "@/api"
import { removeToken } from "@/utils/token";
const mutations = {
    //清除本地数据
    CLEAR(state) {
        //帮仓库关掉、清空用户信息
        state.token = '';
        state.userInfo = {};
        //本地存储清空
        removeToken();
    }
}
const actions = {
        //退出登录
    async userLogout({ commit }) {
        //知识向服务器发起一次请求，通知服务器清除token
        let result13 = await reqLogout();
        //actions将数据提交到mutations里修改state
        if (result13.code == 200) {
            commit("CLEAR");
            return 'ok';
        } else {
            return Promise.reject(new Error("faile"))
        }
    }
}
```

再补写`Header组件`

```html
<template>
......
		<a class="register" @click="logout">退出登录</a>
......
</template>
<script>
......
methods:{
   async logout(){
      try{
        //退出登录需要：1.发请求【通知服务器退出登录清除数据(例如token)】；2.清除项目中的数据【userInfo、token】
        await this.$store.dispatch("userLogout")
        //退出成功，回到首页
        this.$router.push("/home")
      }catch{}
   }
}
......
</script>
```

到此为止，界面还不够完善，例如：未登录时，可以直接跳转到购物车信息

## 43. 导航守卫理解

在`路由router文件`中定义

```js
//配置路由
let router = new VueRouter({
    //配置路由
    routes: routes,
    scrollBehavior(to, from, savedPosition) {
        return { y: 0 }
    }
});

//全局守卫：前置守卫（在路由跳转之间进行判断）
router.beforeEach((to, from, next) => {
    //to:可获取到要跳转的那个路由信息
    //from:可获取到从哪个路由而来的信息
    //next:放行函数
    // 写法一：next()直接放行    写法二：next(path)放行到指定路由     写法三：next(false)若URL改变，则中断跳回from路由
    next();
})

export default router;
```

`仓库state`中有token，所以可以直接在`router文件`中引入`仓库state`，在`router文件中`向`state`拿到token。

### 43.1 导航守卫的判断与操作

（比较绕。。。）

补写`router文件`中

```js
//配置路由
let router = new VueRouter({
    //配置路由
    routes: routes,
    scrollBehavior(to, from, savedPosition) {
        return { y: 0 }
    }
});

//全局守卫：前置守卫（在路由跳转之间进行判断）
router.beforeEach(async(to, from, next) => {
    //to:可获取到要跳转的那个路由信息
    //from:可获取到从哪个路由而来的信息
    //next:放行函数
    // 写法一：next()直接放行    写法二：next(path)放行到指定路由     写法三：next(false)若URL改变，则中断跳回from路由
    let token = store.state.user.token;
    //如果token是''，if(token)得到也是真，此时需要判断用户信息（用户名）
    let name = store.state.user.userInfo.name;
    //用户已经登录后
    if (token) {
        //用户已经登录了就不能去登录或注册页面，只允许停留在首页
        if (to.path == '/login' || to.path == '/register') {
            next('/home')
        } else {
            //登录但是不是去/login
            //若已存在用户名
            if (name) {
                next();
            } else {
                //没有用户信息，则派发action让仓库存储用户信息再跳转
                try {
                    //获取用户信息展示成功
                    await store.dispatch('getUserInfo');
                    //放行
                    next()
                } catch (error) {
                    //服务器过期了，token失效的情况下
                    //清除token(用了退出登录那里)
                    await store.dispatch('userLogout')
                    next('/login');
                }
            }
        }
    } else {
        //未登录
        next();
    }
})

export default router;
```

## 44. trade交易静态组件



用老师的账号和密码：13700000000    111111

将`ShopCart组件`中的结算业务加上点击事件，进行页面跳转

```html
<template>
......
         <div class="sumbtn">
          <a class="sum-btn" @click="$router.push('/trade')">结算</a>
        </div>
......
</template>
```

### 44.1 获取trade交易页数据

依旧按步骤，先写`api`

```js
// 获取用户地址信息
// URL: /api/user/userAddress/auth/findUserAddressList   methods：get
export const reqAddressInfo = () => requests({ url: `/user/userAddress/auth/findUserAddressList`, method: "get" })

//获取商品清单
// URL：/api/order/auth/trade   methods：get
export const reqOrderInfo = () => requests({ url: `/order/auth/trade`, method: "get" })
```

再写`trade仓库`

```js
import { reqAddressInfo, reqOrderInfo } from '@/api';
const state = {
    address: [],
    orderInfo: {}
};
const mutations = {
    GETUSERADDRESS(state, address) {
        state.address = address;
    },
    GETORDERINFO(state, orderInfo) {
        state.orderInfo = orderInfo;
    }
};
const actions = {
    //获取用户地址信息
    async getUserAddress({ commit }) {
        let result13 = await reqAddressInfo();
        if (result13.code == 200) {
            commit('GETUSERADDRESS', result13.data);
        }
        console.log(result13);
    },
    //获取商品清单数据
    async getOrderInfo({ commit }) {
        let result15 = await reqOrderInfo();
        if (result15.code == 200) {
            commit("GETORDERINFO", result15.data);
        }
    }
};
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters
}
```

最后再在写`Trade组件`写派发

```html
.....
<script>
  export default {
    name: 'Trade',
    //生命周期函数：挂载完毕
    mounted(){
      this.$store.dispatch("getUserAddress")
      this.$store.dispatch("getOrderInfo")
    }
  }
</script>
```

### 44.2 用户地址信息的展示

用**排他思想**

```html
<template>
......
      <h5 class="receive">收件人信息</h5>
      <div class="address clearFix" v-for="(address,index) in addressInfo" :key="address.id">
        <span class="username" :class="{selected:address.isDefault==1}">{{address.consignee}}</span>
        <p @click="changeDefault(address,addressInfo)">
          <span class="s1">{{address.fullAddress}}</span>
          <span class="s2">{{address.phoneNum}}</span>
          <span class="s3" v-show="address.isDefault==1">默认地址</span>
        </p>
      </div>
......
      <div class="receiveInfo">
        寄送至:
        <span>{{userDefaultAddress.fullAddress}}</span>
        收货人：<span>{{userDefaultAddress.consignee}}</span>
        <span>{{userDefaultAddress.phoneNum}}</span>
      </div>
</template>
<script>
    import {mapState} from'vuex'
......
	    computed:{
      ...mapState({
 addressInfo:state=>state.trade.address
      }),
      //将来选中的地址，提交至右下角订单，成为终选中的地址
      userDefaultAddress(){
      //find:查找数组中符合条件的元素返回
        return this.addressInfo.find(item=>item.isDefault==1)
      }
    },

	//排他思想
    methods:{
      //修改默认地址
      changeDefault(address,addressInfo){
        //全部的isDefault赋值为零
          addressInfo.forEach(item=>item.isDefault=0);
        address.isDefault = 1;
      }
    }
......
</script>
```

### 44.3 交易页面完成

完善`Trade组件`

```html
<template>
......
        <div class="detail">
        <h5>商品清单</h5>
        <ul class="list clearFix" v-for="(order,index) in orderInfo.detailArrayList" :key="order.skuId">
          <li>
            <img :src="order.imgUrl" style="width:100px;height:100px">
          </li>
          <li>
            <p>
              {{order.skuName}}</p>
            <h4>7天无理由退货</h4>
          </li>
          <li>
            <h3>￥{{order.orderPrice}}.00</h3>
          </li>
          <li>X{{order.skuNum}}</li>
          <li>有货</li>
        </ul>
      </div>
    ......
        <li>
          <b><i>{{orderInfo.totalNum}}</i>件商品，总商品金额</b>
          <span>¥{{orderInfo.totalAmount}}.00</span>
        </li>
        <li>
          <b>返现：</b>
          <span>0.00</span>
        </li>
        <li>
          <b>运费：</b>
          <span>0.00</span>
        </li>
    ......
          <div class="price">应付金额:　<span>¥{{orderInfo.totalAmount}}.00</span></div>
......
</template>
<script>
......
    computed:{
      ...mapState({
    orderInfo:state=>state.trade.orderInfo,
      }),
......
</script>
```

**收集买家留言**

```html
<template>
......
       <div class="bbs">
        <h5>买家留言：</h5>
        <textarea placeholder="建议留言前先与商家沟通确认" class="remarks-cont" v-model="msg"></textarea>
      </div>
......
</template>
<script>
......
    data(){
      return{
        //收集买家留言信息
        msg:''
      }
    },
......
</script>
```

## 45. 提交订单（不用vuex）【支付界面建议晚上再试，因为用的账号一样，容易冲突】

由于订单一直无法提交成功，所以暂且将`if(result.code !==200 )`进行下一个页面的学习。将提交订单页面、生成二维码的内容暂时先听一听，试着做了一下。

### 45.1 提交订单静态组件（不用vuex）

在`router文件`中引入路由

```js
import Pay from '@/pages/Pay'
//配置路由,路由的单词都是小写的
export default [{
        path: "/pay",
        component: Pay,
        //meta是显示底下的floor组件的
        meta: { show: true }
    },
]
```

引入接口，写`API`

```js
//提交订单的接口
// URL:/api/order/auth/submitOrder?tradeNo={tradeNo}    method:POST
export const reqSubmitOrder = (tradeNo, data) => requests({ url: `/order/auth/submitOrder?tradeNo=${tradeNo}`, data, method: "post" })
```

在`Trade组件`中修改



### 45.2 提交订单（没有vuex时，可以用的方法）

在`main.js中`写，在`main.js`这里写接口，在`$bus`里写，已经将`$API`挂载在`Vue.prototype`的原型对象上了，就不需要其他组件一个一个引入了。

```js
//统一接口api文件夹里全部的请求函数
import * as API from '@/api';
new Vue({
    render: h => h(App),
    //引入路由之后要注册路由：以下的写法是KV键值对，一致省略V【router应小写】
    //全局事件总线$bus配置
    beforeCreate() {
        Vue.prototype.$API = API;
    },
```

直接在`Trade组件`中使用

```html
<template>
......
    <div class="sub clearFix">
      <a class="subBtn" @click="submitOrder">提交订单</a>
    </div>
......
</template>
<script>
......
data(){
    return{
        //订单号
        orderId:"",
    }
}
methods:{
     //提交订单
    async submitOrder() {
      let { tradeNo } = this.orderInfo;
      //其余六个参数
      let data = {
        consignee: this.userDefaultAddress.consignee,//最终收件人的名字
        consigneeTel: this.userDefaultAddress.phoneNum,//最终收件人的手机号
        deliveryAddress: this.userDefaultAddress.fullAddress,//收件人的地址
        paymentWay: "ONLINE",//支付方式
        orderComment: this.msg,//买家留言信息
        orderDetailList: this.orderInfo.deliveryAddress,//商品清单
      };
      //带参数tradeNo
      let result = await this.$API.reqSubmitOrder(tradeNo,data);
      console.log(result)
    },
}
       //带参数tradeNo
      let result = await this.$API.reqSubmitOrder(tradeNo,data);
      //提交订单成功（这里暂时写不成功）
      if(result.code !==200 ){
        this.orderId = result.data;
        //路由跳转+路由传参
        this.$router.push('/pay?orderId='+this.orderId)
        //提交订单失败（暂时反着写）
      }else{
        alert(result.data);
      }
......
</script>
```

【支付跳转暂时完不成，因为有其他人在操作，晚上在弄一下看看】暂且将`if(result.code !==200 )`进行下一个页面的学习。

## 46. 获取订单号与展示信息（不用vuex）【支付界面建议晚上再试，因为用的账号一样，容易冲突】

在`pay组件`中

```html
<template>
......
		<span class="fl">请您在提交订单<em class="orange time">4小时</em>之内完成支付，超时订单会自动取消。订单号：<em>{{orderId}}</em></span>
......
</template>
<script>
  export default {
    name: 'Pay',
    computed:{
      orderId(){
        return this.$route.query.orderId;
      }
    }
  }
</script>
```

发请求写接口`api`

```js
//获取支付信息接口
// URL:/api/payment/weixin/createNative/{orderId}   method:get
export const reqPayInfo = () => requests({ url: `/payment/weixin/createNative/${orderId}`, method: "get" })
```

再在`Pay组件`中补写：

```html
<template>
......
	<span class="fr"><em class="lead">应付金额：</em><em class="orange money">￥{{payInfo.totalFee}}</em></span>
......
</template>
<script>
......
  export default {
	......
    data(){
      return{
        payInfo:{}
    }    
    //尽量别在生命周期函数中写async或await
    mounted(){
      this.getPayInfo();
    },
    methods:{
      async getPayInfo(){
        let result16 = await this.$API.reqPayInfo(this.orderId);
        //如果成功：组件当中存储支付信息
        if(result.code == 200){
          this.payInfo = result16.data;
        }
        // console.log(result16)
      }
    }
    ......
  }
......
</script>
```

## 47. 支付页面中使用Element UI以及按需引入



**React（Vue）**组件库大概有：antd[PC]  antd-mobile[移动端]

**Vue**组件库大概有：ElementUI[PC]   vant[移动端]

一、安装Element UI

`npm install --save element-ui`

二、本次用按需引入

`npm install babel-plugin-component -D`

然后，将 `.babelrc` 修改为：

```js
{
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
```

三、ElementUI按需引入，配置文件发生变化后，项目需重启。

四、按需在`main.js`引入

```js
//按需引入Element-UI
import { Button } from 'element-ui';
//import { MessageBox } from 'element-ui';
......
//使用方法一：
Vue.component(Button.name, Button);
//使用方法二：
//ElementUI注册全局组件时，可写在原型上
//Vue.prototype.$msgbox = MessageBox;
//Vue.prototype.$alert = MessageBox.alert;
......
```

五、在`pay组件`中的写法

```html
<template>
......
	<a class="btn" @click="open">立即支付</a>
......
</template>
<script>
......
methods:{
          //弹出框
      open() {
        this.$alert('这是一段内容', '标题名称', {
          dangerouslyUseHTMLString:true,
          //中间布局
          center:true,
          //是否显示取消按钮
          showCancelButton:true,
          //取消按钮的文本内容
          cancelButtonText:"支付遇见问题",
          //确定按钮的文本
          confirmButtonText:'已支付成功',
          //关闭右上角的X
          showClose:false
        });
      }
}
......
</script>
```





## 48. 微信支付业务（上）

### 48.1 二维码生成（QRCODE）

生成二维码

用`qrcode插件`

一、先进行安装`qrcode`插件：`npm install qrcode --save`

二、生成二维码，补写`pay组件`

```html
<script>
......
      //弹出框
      async open() {
        //生成二维码（地址）
        let url = await QRCode.toDatatURL(this.payInfo.codeUrl);
        this.$alert(`<img src = ${url} /`, '请使用微信支付', {
        this.$alert(`放置二维码的地方`, '请使用微信支付', {
          dangerouslyUseHTMLString:true,
          //中间布局
          center:true,
          //是否显示取消按钮
          showCancelButton:true,
          //取消按钮的文本内容
          cancelButtonText:"支付遇见问题",
          //确定按钮的文本
          confirmButtonText:'已支付成功',
          //关闭右上角的X
          showClose:false,
          //beforeClose关闭前的回调，会暂停实例的关闭
          beforeClose:(type,instance,done) =>{
            //type：区分取消||确定按钮
            //instance：当前组件实例
            //done：关闭弹出框方法
            if(type=='cancel'){
              alert('请联系管理员');
              //清除定时器
              clearInterval(this.timer);
              this.timer = null;
              //关闭弹出框
              done();
            }else{
              //判断是否真的支付了
              if(this.code !== 200){//由于实操较困难，故将if(this.code == 200)改为if(this.code !== 200)
              clearInterval(this.timer);
              this.timer = null;
              done();
              this.$router.push("/paysuccess");
              }
            }
          }
        });
        //支付成功，路由跳转；若失败则给客户提示
      }
......
</script>
```

### 48.2 获取支付订单状态

获取`API`

```JS
//获取支付订单状态
// URL:/api/payment/weixin/queryPayStatus/{orderId}  mehods:Get
export const reqPayStatus = (orderId) => requests({ url: `/payment/weixin/queryPayStatus/${orderId}`, method: 'get' });
```

完善组件`Pay组件`

```vue
<script>
......
data(){
      return{
        timer:null,
        //支付状态码
        code:''
      }
    ......
methods:{
            //支付成功，路由跳转；若失败则给客户提示
        if(!this.timer){
          this.timer = setInterval(async()=>{
            //发送请求获取用户支付状态
            let result = await this.$API.reqPayStatus(this.orderId);
            //如果code==200（因为支付界面的原因这里先写成code!==200）
            if(result.code!==200){
              //一、清除定时器
              clearInterval(this.timer);
              this.timer = null;
              //二、保存支付成功返回的code，以防用户未完成支付而点击完成支付
              this.code = result.code;
              //关闭弹出框
              this.$msgbox.close();
              //跳转到下一个路由
              this.$router.push('/paysuccess')
            }
          },1000)
        }
}
......
</script>
```

# Day10

## 49. 个人中心——二级路由搭建

在`routes.js`中注册`center的路由`

```js
import Center from '@/pages/Center'
//配置路由,路由的单词都是小写的
export default [{
        path: "/center",
        component: Center,
        //meta是显示底下的floor组件的
        meta: { show: true }
    }
......]
```

在`routes.js`中引入它的二级路由

```js
import Center from '@/pages/Center'
//引入二级路由组件
//引入组件
import myOrder from '@/pages/Center/myOrder'
import groupOrder from '@/pages/Center/groupOrder'
//配置路由,路由的单词都是小写的
export default [{
        path: "/center",
        component: Center,
        //meta是显示底下的floor组件的
        meta: { show: true },
        //二级路由组件
        children: [{
                path: "myorder",
                component: myOrder
            },
            {
                path: "grouporder",
                component: groupOrder
            },
            {
                path: '/center',
                redirect: '/center/myorder'
            }
        ],
    },
......]
```

在`Center组件`中写入

```html
<template>
......
        <!--左侧列表-->
        <div class="order-left">
          <dl>
            <dt><i>·</i> 订单中心</dt>
            <dd>
              <router-link to="/center/myorder">我的订单</router-link>
            </dd>
            <dd>
              <router-link to="/center/grouporder">团购订单</router-link>
            </dd>
            </dl>
    </div>
  ..........
        <!-- 右侧内容 -->
        <!-- 路由组件出口的位置 -->
        <router-view></router-view>
......
</template>
```

## 50. 我的订单

写接口`/api/order/auth/{page}/{limit}`

用到了路由导航、分页器、v-for循环等知识点。由于无法成功支付，故本节课无法展示具体内容点。代码在`myOrder组件`中，可自行查看。

## 51. 未登录的导航守卫判断

未登录的访问，无法访问交易相关（trade）、支付相关（pay、paysuccess）、用户中心相关（center），点击后只能跳转到登录页面。

所以在`router文件夹`下的`index.js`对之前的内容进行修改

```js
//全局守卫：前置守卫（在路由跳转之间进行判断）
router.beforeEach(async(to, from, next) => {
        if (token) {
            ......
        }else {
        //未登录的访问，无法访问交易相关（trade）、支付相关（pay、paysuccess）、用户中心相关（center），点击后只能跳转到登录页面。
        let toPath = to.path;
        //如果toPath中带有
        if (toPath.indexOf('/trade') != -1 || toPath.indexOf('/pay') != -1 || toPath.indexOf('/center') != -1) {
            //把未登录的时候去而未去成的信息，存储于地址栏【路由】中
            next('/login?redirect=' + toPath);
        } else {
            //对其他的组件访问均可放行
            next();
        }
    }
}
```

在`Login组件`中补写：

```html
<script>
......
  methods: {
    //登录的回调函数
    async userLogin() {
      try {
        // const phone = this phone;
        // const password = this password;
        // 简写形式：
        const { phone, password } = this;
        phone && password && (await this.$store.dispatch("userLogin", { phone, password }));
        //跳转到home首页
        let toPath = this.$route.query.redirect||"/home"
        this.$router.push(toPath)
      } catch (error) {
        alert(error.message);
      }
    },
  },
......
</script>
```

## 52. 用户登录（路由独享与组件内守卫）

全局前置守卫(常用)、全局解析守卫、全局后置钩子、路由独享守卫(常用)、组件内守卫

### 52.1 路由独享守卫

在路由文件`routes.js`文件中写：

```js
export default [
    ......
        {
        path: "/pay",
        component: Pay,
        //meta是显示底下的floor组件的
        meta: { show: true },
        //路由独享守卫
        beforeEnter: (to, from, next) => {
            if (from.path == "/trade") {
                next();
            } else {
                next(false);
            }
        }
    },
    {
        path: "/trade",
        component: Trade,
        //meta是显示底下的floor组件的
        meta: { show: true },
        //路由独享守卫
        beforeEnter: (to, from, next) => {
            if (from.path == "/shopcart") {
                next();
            } else {
                next(false);
            }
        }
    },
    ......
]
```

### 52.2 组件内守卫(用得不多)

本节在`paysuccess组件`中书写使用

```html
<script>
......
export default {
  name: 'PaySuccess',
    //组件内守卫
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
    // 如果是从pay路由来，那么就放行，否则就在原地
    if(from.path == "/pay"){
      next();
    }else{
      next(false)
    }
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
    console.log("beforeRouteUpdate")
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
    // 一般情况直接放行就行了
    next();
  }
}
......
</script>
```

## 53. 图片懒加载（插件：vue-lazyload）

### 53.1 图片懒加载——一

图片懒加载的插件：

https://www.npmjs.com/package/vue-lazyload

**第一步：**安装插件

`npm i vue-lazyload -S `

**第二步：**在入口文件`main.js`中引入

```js
//引入插件
import VueLazyload from 'vue-lazyload'
//引入需使用的图片
import green from '@/assets/green.gif'
//注册插件
Vue.use(VueLazyload, {
        //懒加载默认的图片
        loading: green
    })
```

**第三步：**使用该指令（找到需要使用图片懒加载的图片，进行替换）

本节由`Search组件`使用，

将

`<img :src="good.defaultImg"/>`

替换成

`<img v-lazy="good.defaultImg"/>`

### 53.2 自定义插件【自己再查查】

。。。。。。。

## 54. 表单验证（插件：vee-validate）【了解即可，看懂就行】

**第一步：**先安装2版本的`npm i vee-validate@2 --save`

**第二步：**引用表单校验插件

由于入口文件`main.js`里面的内容太多了，新建一个文件写`validata.js`插件：

```js
//vee-validate插件：表单验证区域
import Vue from 'vue';
import VeeValidate from 'vee-validate';

//使用插件
Vue.use(VeeValidate)

//中文提示信息
import zh_CN from 'vee-validate/dist/locale/zh_CN'

//表单验证
VeeValidate.Validator.localize('zh_CN', {
    messages: {
        ...zh_CN.messages,//转成中文
        is: (field) => `${field}必须与密码相同` //修改内容规则的message，让确认密码和密码相同
    },
    attributes: {
        phone: '手机号',
        code: '验证码',
        password: '密码',
        password1: '确认密码',
        agree: '协议'
    },
});

//自定义校验规则
VeeValidate.Validator.extend("tongyi", {
    validate: (value) => {
        return value;
    },
    getMessage: (field) => field + '必须同意'
})
```

在入口文件`main.js`引入

```js
//引入表单校验插件
import "@/plugins/validate"
```

**第三步：**基本使用

在`Register组件`中使用：

```html
<template>
......
      <div class="content">
        <label>手机号:</label>
        <input
          placeholder="请输入手机号"
          v-model="phone"
          name="phone"
          v-validate="{ required: true, regex: /^1\d{10}$/ }"
          :class="{ invalid: errors.has('phone') }"
        />
        <span class="error-msg">{{ errors.first("phone") }}</span>
      </div>
      <div class="content">
        <label>验证码:</label>
        <input
          placeholder="请输入验证码"
          v-model="code"
          name="code"
          v-validate="{ required: true, regex: /^\d{6}$/ }"
          :class="{ invalid: errors.has('code') }"
        />
        <button style="width: 100px; height: 38px" @click="getCode">
          获取验证码
        </button>
        <span class="error-msg">{{ errors.first("code") }}</span>
      </div>
      <div class="content">
        <label>登录密码:</label>
        <input
          placeholder="请输入密码"
          v-model="password"
          name="password"
          v-validate="{ required: true, regex: /^[0-9A-Za-z]{8,20}$/ }"
          :class="{ invalid: errors.has('password') }"
        />
        <span class="error-msg">{{ errors.first("password") }}</span>
      </div>
      <div class="content">
        <label>确认密码:</label>
        <input
          placeholder="请再一次输入密码"
          v-model="password1"
          name="password1"
          v-validate="{ required: true, is: password }"
          :class="{ invalid: errors.has('password1') }"
        />
        <span class="error-msg">{{ errors.first("password1") }}</span>
      </div>
      <div class="controls">
        <input
          type="checkbox"
          v-model="agree"
          name="agree"
          v-validate="{ required: true, 'tongyi':true }"
          :class="{ invalid: errors.has('agree') }"
        />
        <span>同意协议并注册《尚品汇用户协议》</span>
        <span class="error-msg">{{ errors.first("agree") }}</span>        
      </div>
......
</template>
<script>
......
    //用户注册完善、修改
    async userRegister() {
      const success = await this.$validator.validateAll();
      //全部表单验证成功再像服务器发请求进行注册，若有一个表单没有成功则都不会发请求
      if (success) {
        try {
          const { phone, code, password, password1 } = this;
            await this.$store.dispatch("userRegister", {
              phone,
              code,
              password,
            });
          //注册成功进行路由跳转
          this.$router.push("./login");
        } catch (error) {
          alert("fail");
        }
      }
    },
......
</script>
```

## 55. 路由的懒加载

当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。类似于按需引入。

**路由懒加载优点：高效**

**官方写法：**

```js
const Foo = () => import('./Foo.vue')
const router = new VueRouter({
  routes: [{ path: '/foo', component: Foo }]
})
```

**按照官方写法在`router.js`中完整写法：**

```js
......
const Foo = () => {
    return import ("@/pages/Home/index.vue")
}
......
export default [
{
        path: "/home",
        component: Foo,
        meta: { show: true }
    },
]
```

**将其简写的过程如下：**

```js
const Foo = () => {
    return import ("@/pages/Home/index.vue")
}
//可以简写为：
const Foo = () => return import ("@/pages/Home/index.vue")
//简化替换，可将下方的component组件简写为：
export default [
{
        path: "/home",
        component: () => return import ("@/pages/Home/index.vue")
        meta: { show: true }
    },
]
```

**最终可直接简写得：**

```js
......
export default [
{
        path: "/home",
        component: () => return import("@/pages/Home/index.vue")//箭头函数返回Promise，只有在该组件被调用时才会使用。
        meta: { show: true }
    },
]
......
```

# Day11

## 56. 处理map文件、打包上线

使用`npm run build`将项目打包上线。打包上线后的代码都是经过压缩加密的，若运行报错则无法准确得知是哪里的代码报错。打包上线后之后，得到`dist文件夹`，`dist文件夹`里的`js文件夹`里有.map结尾的文件。

**.map文件可以像未加密的代码一样，准确输出是哪一行哪一列有错误。**

所以如果项目不需要，`.map文件`是可以手动删除的。

也可以在项目打包上线之前，在`配置文件vue.config.js文件`里加上`productionSourceMap:false`这一行代码，打包之后就不会出现.map文件，项目的体积就会缩小一些。

`vue.config.js文件`：

```js
module.exports = {
    productionSourceMap: false,
    //关闭eslint
    lintOnSave: false,

    //代理跨域
    devServer: {
        proxy: {
            '/api': {
                target: 'http://39.98.123.211',
                // pathRewrite: { '^/api': '' }, //因为本次项目的接口都已经带/api了，所以这里的路径可以不用写。
            },
        },
    },
}
```

## 57. 购买服务器等操作

暂未购买，先了解

视频中的老师建议腾讯云（因为便宜），目前有活动——星星海 云服务器

### 57.1 利用xshell工具登录服务器

linux：/根目录

linux常用指令：cd 跳转目录、ls查看、mkdir创建目录、pwd：查看绝对路径。

### 57.2 nginx反向代理

**nginx配置**

**1.**xshell进入根目录/etc

**2.**进入etc目录，若这个目录下有一个nginx目录，进到这个目录【需提前安装好nginx】

在etc文件下配置nginx

**3.**安装nginx:`yum install nginx`

**4.**安装完nginx服务器后，在nginx目录下，多了一个`nginx.conf文件`，在这个文件中进行配置。

**5.**vim nginx.conf进行编辑，主要添加如下俩：

**解决第一个问题：**为什么访问服务器IP地址即可访问到自己的项目？——在服务器上=>/root/jch/www/shangpinhui/dist;,需要进行一些配置。

```linux
location/{
root    /root/jch/www/shangpinhui/dist;
index    index.html;
try_files    $uri  $uri/    /index.html;
}
```

**解决第二个问题：**项目的数据来自于http://39.98.123.211？

```linux
location  /api{
proxy_pass  http://39.98.123.211;
}
```

**6,**nginx服务器跑起来：`service nginx start`

